import glob from 'glob';

import crypto from 'node:crypto';
import fs from 'node:fs/promises';
import path from 'node:path';

import { type AnyFunction, captureStackTrace, logger } from '@andrew_l/toolkit';

export type Factory = any;

export type Service = {
  factory?: Factory;
  constructorName?: string;
  constructorPath?: string;
  instance: any;
};

export interface SetupOptions {
  pathRoot?: string;

  /**
   * Absolute or relative path where generated type file will be saved
   */
  typeOutput?: string;

  /**
   * Absolute or relative glob patterns to auto-import service files
   */
  autoImportPatterns?: string[];

  /**
   * Should generate type file
   */
  generateTypes?: boolean;
}

const storage = new Map<string, Service>();

const log = logger(import.meta, 'IOC');

export default {
  get<T>(id: string): T {
    const service = storage.get(id);

    if (!service) {
      throw new Error(`No service is registered for [${id}]`);
    }

    if (!service.instance) {
      service.instance = service.factory?.();
      service.factory = undefined;
    }

    return service.instance;
  },

  set(
    id: string,
    factoryOrClassReference: Factory | AnyFunction,
    buildInstantly: boolean = false,
  ) {
    if (this.isSet(id)) {
      throw new Error(`Service [${id}] is already registered`);
    }

    let constructorPath: string | undefined;

    try {
      constructorPath = new URL(
        captureStackTrace(this.set).split('\n')[0].slice(7),
      ).pathname.split(':')[0];
    } catch (_) {}

    this.override(id, factoryOrClassReference, buildInstantly, constructorPath);
  },

  override(
    id: string,
    factoryOrClassReference: Factory | AnyFunction,
    buildInstantly: boolean = false,
    constructorPath?: string,
  ) {
    const factory: Factory = getFactory(factoryOrClassReference);

    storage.set(id, {
      factory: buildInstantly ? undefined : factory,
      instance: buildInstantly ? factory() : undefined,
      constructorName: getConstructorName(factoryOrClassReference),
      constructorPath,
    });
  },

  isSet(id: string): boolean {
    return storage.has(id);
  },

  clear() {
    storage.clear();
  },

  async setup({
    pathRoot = process.cwd(),
    generateTypes = false,
    autoImportPatterns = ['./services/*/**/*.service.{js,mjs,ts,mts,cts}'],
    typeOutput = './ioc.d.ts',
  }: SetupOptions | undefined = {}) {
    typeOutput = path.isAbsolute(typeOutput)
      ? typeOutput
      : path.join(pathRoot, typeOutput);

    if (!typeOutput.endsWith('.d.ts')) {
      typeOutput = path.join(typeOutput, 'ioc.d.ts');
    }

    autoImportPatterns = autoImportPatterns.map(servicePath => {
      return path.isAbsolute(servicePath)
        ? servicePath
        : path.join(pathRoot, servicePath);
    });

    log.debug('Setup', {
      pathRoot,
      generateTypes,
      autoImportPatterns,
      typeOutput,
    });

    await this.importServices(autoImportPatterns);

    if (generateTypes) {
      await this.writeTypes(typeOutput);
    }
  },

  async importServices(autoImportPatterns: string[]) {
    for (const pattern of autoImportPatterns) {
      for (const filePath of glob.sync(pattern)) {
        await import(filePath);
      }
    }
  },

  async writeTypes(outputFilePath: string) {
    const typesDefinitions: string[] = [];
    const outputFolderPath = path.dirname(outputFilePath);

    for (const [
      key,
      { constructorName, constructorPath },
    ] of storage.entries()) {
      if (!constructorName) continue;
      if (!constructorPath) continue;

      typesDefinitions.push(
        `"${key}": import('./${path.relative(
          outputFolderPath,
          constructorPath,
        )}').${constructorName};`,
      );
    }

    const typesContent = `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Generated by @andrew_l/ioc

export {};

declare module '@andrew_l/ioc' {
	interface IocMap {
		${typesDefinitions.sort().join('\n\t\t')}
	}

	function ioc<Key extends keyof IocMap>(id: Key): IocMap[Key];
}`;

    const newHash = crypto
      .createHmac('sha256', '')
      .update(typesContent)
      .digest('hex');

    const oldHash = await getHashFromTypeFile(outputFilePath);

    if (newHash !== oldHash) {
      log.warn('Types file has been updated.');

      await fs.writeFile(
        outputFilePath,
        `// hash:${newHash}\n${typesContent}\n`,
      );
    }
  },
};

function isConstructable(obj: any): obj is Function {
  // https://stackoverflow.com/a/46320004
  return !!obj.prototype && !!obj.prototype.constructor.name;
}

function getFactory(factoryOrClassReference: Factory | AnyFunction): Factory {
  return isConstructable(factoryOrClassReference)
    ? () => new factoryOrClassReference()
    : factoryOrClassReference;
}

function getConstructorName(
  factoryOrClassReference: Factory | AnyFunction,
): string {
  return isConstructable(factoryOrClassReference)
    ? factoryOrClassReference.prototype.constructor.name
    : String(factoryOrClassReference).match(/new\s(\w+)\(/)?.[1] || '';
}

async function getHashFromTypeFile(filePath: string): Promise<string | null> {
  try {
    const content = await fs.readFile(filePath, { encoding: 'utf8' });
    const lastLine = content.split('\n').at(0);

    return lastLine?.split('hash:')[1] || null;
  } catch (_) {
    return null;
  }
}
