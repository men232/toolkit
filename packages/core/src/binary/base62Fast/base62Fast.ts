import type { BaseX } from '../basex';

var ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var ENCODE_TABLE = new TextEncoder().encode(ALPHABET);
var DECODE_TABLE = new Uint8Array(256);
for (let i = 0; i < ENCODE_TABLE.length; ++i) {
  DECODE_TABLE[ENCODE_TABLE[i]] = i;
}

var LOG2_TABLE = new Uint8Array(62);
LOG2_TABLE[0] = 1;
for (let i = 1; i < 62; ++i) {
  LOG2_TABLE[i] = Math.ceil(Math.log2(i + 1));
}

const allocEncode = createAllocator();

/**
 * Base62-like encoder/decoder for binary data but **super fast**
 *
 * @example Basic usage
 * ```typescript
 * const data = new Uint8Array([255, 128, 64]);
 * const encoded = base62.encode(data);
 * console.log(encoded);
 *
 * const decoded = base62.decode(encoded);
 * console.log(decoded); // Uint8Array [255, 128, 64]
 * ```
 *
 * @example Text encoding
 * ```typescript
 * const text = "Hello World!";
 * const bytes = new TextEncoder().encode(text);
 * const encoded = base62.encode(bytes);
 * const decoded = base62.decode(encoded);
 * const result = new TextDecoder().decode(decoded);
 * console.log(result); // "Hello World!"
 * ```
 *
 * @group Binary
 */
export const base62Fast: BaseX = {
  alphabet: ALPHABET,
  padding: '',

  /**
   * Encodes a Uint8Array into a Base62 string using a custom 5/6-bit variable length scheme.
   * Processes bits from right to left (most significant bit first conceptually).
   * @param input The Uint8Array to encode.
   * @returns The encoded Base62 string.
   */
  encode(input: Uint8Array): string {
    var position = input.length * 8;
    var output: Uint8Array = allocEncode(((position / 5) | 0) + 1);
    var outputIndex = 0;

    var chunkSize;
    var remainderBits;
    var byteIndex;
    var extractedBits;
    var value;

    while (position > 0) {
      chunkSize = 6; // Default to 6 bits

      // Calculate byteIndex and remainderBits for the current position
      remainderBits = position & 7;
      byteIndex = position >>> 3;

      // Adjust for byte boundaries: if position is a multiple of 8, it means
      // we are at the beginning of a byte, so move to the end of the previous byte.
      if (remainderBits === 0) {
        byteIndex -= 1;
        remainderBits = 8;
      }

      // Extract the relevant bits. This gets the 'remainderBits' high bits of the current byte.
      extractedBits = input[byteIndex] >> (8 - remainderBits);

      // If we need more bits than available in current 'remainderBits' but less than 6
      if (remainderBits < 6 && byteIndex > 0) {
        extractedBits |= input[byteIndex - 1] << remainderBits;
      }

      // Get the lowest 6 bits to map to a character value (0-63)
      value = extractedBits & 0x3f;

      // Custom 5-bit encoding logic:
      if ((value & 0x1e) === 0x1e) {
        if (position > 6 || value > 0x1f) {
          chunkSize = 5;
          value &= 0x1f;
        }
      }

      // Store the character for the current value
      output[outputIndex++] = ENCODE_TABLE[value];
      position -= chunkSize;
    }

    return new TextDecoder().decode(output.subarray(0, outputIndex));
  },

  /**
   * Decodes a Base62 string generated by the custom encoder back into a Uint8Array.
   * @param input The Base62 string to decode.
   * @returns The decoded Uint8Array.
   */
  decode(input: string): Uint8Array {
    var inputLength = input.length;

    var maxOutputLength = ((inputLength * 6) / 8) | 0;
    var output = new Uint8Array(maxOutputLength);

    var writeIndex = maxOutputLength;
    var bitPosition = 0;
    var buffer = 0;
    var charCode = 0;
    var value = 0;

    for (var readIndex = 0; readIndex < inputLength; readIndex++) {
      charCode = input.charCodeAt(readIndex);
      value = DECODE_TABLE[charCode];

      // Validate character: must be in the alphabet
      if (isNaN(charCode) || value === undefined) {
        throw new Error(
          'Invalid Base62 input: contains non-alphabet characters.',
        );
      }

      // Add the decoded value to the buffer.
      buffer |= value << bitPosition;

      // Determine how many bits this character represents based on its position and value.
      if (readIndex === inputLength - 1) {
        // If it's the very last character
        if (LOG2_TABLE[value] === undefined) {
          throw new Error(
            'Invalid Base62 input: unexpected value for last character.',
          );
        }
        bitPosition += LOG2_TABLE[value]; // Consume bits based on the value (e.g., 0-1 consume 1 bit, 32-61 consume 6 bits)
      } else if ((value & 0x1e) === 0x1e) {
        bitPosition += 5; // Consume 5 bits
      } else {
        bitPosition += 6; // Consume 6 bits
      }

      // If we have accumulated 8 or more bits, write a complete byte to output
      if (bitPosition >= 8) {
        output[--writeIndex] = buffer;
        bitPosition &= 7;
        buffer >>= 8;
      }
    }

    // After loop, if there are remaining bits in the buffer, write the last partial byte
    if (bitPosition > 0) {
      output[--writeIndex] = buffer;
    }

    // Return the relevant part of the output array (from writeIndex to end)
    return output.subarray(writeIndex);
  },
};

function createAllocator(): (size: number) => Uint8Array {
  var currentBuffer = new Uint8Array(512);
  var currentSize = 512;

  return (size: number) => {
    if (currentSize < size) {
      currentBuffer = new Uint8Array(size);
      currentSize = size;
    }
    return currentBuffer;
  };
}
