import { textDecoder } from '@/str';
import type { BaseX } from '../basex';

var ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var ENCODE_TABLE = new TextEncoder().encode(ALPHABET);
var DECODE_TABLE = new Uint8Array(128);
for (let i = 0; i < ENCODE_TABLE.length; ++i) {
  DECODE_TABLE[ENCODE_TABLE[i]] = i;
}

var LOG2_TABLE = new Uint8Array(62);
LOG2_TABLE[0] = 1;
for (let i = 1; i < 62; ++i) {
  LOG2_TABLE[i] = Math.ceil(Math.log2(i + 1));
}

var allocEncode = createAllocator();

/**
 * Base62-like encoder/decoder for binary data but **super fast**. Useful for human readable tokens generation
 *
 * **Warning!** Not RFC standard
 *
 * @example Basic usage
 * ```typescript
 * const data = new Uint8Array([255, 128, 64]);
 * const encoded = base62.encode(data);
 * console.log(encoded);
 *
 * const decoded = base62.decode(encoded);
 * console.log(decoded); // Uint8Array [255, 128, 64]
 * ```
 *
 * @example Text encoding
 * ```typescript
 * const text = "Hello World!";
 * const bytes = new TextEncoder().encode(text);
 * const encoded = base62.encode(bytes);
 * const decoded = base62.decode(encoded);
 * const result = new TextDecoder().decode(decoded);
 * console.log(result); // "Hello World!"
 * ```
 *
 * @group Binary
 */
export const base62Fast: BaseX = {
  alphabet: ALPHABET,
  padding: '',

  /**
   * Encodes a Uint8Array into a Base62 string using a custom 5/6-bit variable length scheme.
   * Processes bits from left to right maintaining correct order.
   * @param input The Uint8Array to encode.
   * @returns The encoded Base62 string.
   */
  encode(input: Uint8Array): string {
    var totalBits = input.length * 8;
    var output: Uint8Array = allocEncode(((totalBits / 5) | 0) + 1);
    var outputIndex = 0;

    var bitPosition = 0;
    var buffer = 0;
    var inputIndex = 0;
    var chunkSize;
    var value;

    // Fill buffer with first byte if available
    if (input.length > 0) {
      buffer = input[0];
      inputIndex = 1;
      bitPosition = 8;
    }

    while (bitPosition > 0 || inputIndex < input.length) {
      // Ensure we have enough bits in buffer
      while (bitPosition < 6 && inputIndex < input.length) {
        buffer |= input[inputIndex] << bitPosition;
        inputIndex++;
        bitPosition += 8;
      }

      if (bitPosition === 0) break;

      // Extract value (take from least significant bits)
      value = buffer & 0x3f;
      chunkSize = 6; // Default to 6 bits

      // Custom 5-bit encoding logic
      if ((value & 0x1e) === 0x1e) {
        // Check if we should use 5 bits instead
        var remainingBits = bitPosition + (input.length - inputIndex) * 8;
        if (remainingBits > 6 || value > 0x1f) {
          chunkSize = 5;
          value &= 0x1f;
        }
      }

      // Store the character for the current value
      output[outputIndex] = ENCODE_TABLE[value];
      outputIndex++;

      // Remove processed bits from buffer
      buffer >>= chunkSize;
      bitPosition -= chunkSize;
    }

    return textDecoder.decode(output.subarray(0, outputIndex));
  },

  /**
   * Decodes a Base62 string generated by the custom encoder back into a Uint8Array.
   * @param input The Base62 string to decode.
   * @returns The decoded Uint8Array.
   */
  decode(input: string): Uint8Array {
    var inputLength = input.length;

    var maxOutputLength = ((inputLength * 6) / 8) | 0;
    var output = new Uint8Array(maxOutputLength + 1);

    var writeIndex = 0;
    var bitPosition = 0;
    var buffer = 0;
    var charCode = 0;
    var value = 0;
    var bitsToAdd = 0;

    // Process characters from left to right (same as original)
    for (var readIndex = 0; readIndex < inputLength; readIndex++) {
      charCode = input.charCodeAt(readIndex);
      value = DECODE_TABLE[charCode];

      // Validate character: must be in the alphabet
      if (isNaN(charCode) || value === undefined) {
        throw new Error(
          'Invalid Base62 input: contains non-alphabet characters. Index: ' +
            readIndex,
        );
      }

      // Determine how many bits this character represents
      if (readIndex === inputLength - 1) {
        // If it's the very last character
        if (LOG2_TABLE[value] === undefined) {
          throw new Error(
            'Invalid Base62 input: unexpected value for last character.',
          );
        }
        bitsToAdd = LOG2_TABLE[value];
      } else if ((value & 0x1e) === 0x1e) {
        bitsToAdd = 5; // Consume 5 bits
      } else {
        bitsToAdd = 6; // Consume 6 bits
      }

      // Add the decoded value to the buffer
      buffer |= value << bitPosition;
      bitPosition += bitsToAdd;

      // If we have accumulated 8 or more bits, write complete bytes to output
      while (bitPosition >= 8) {
        output[writeIndex] = buffer & 0xff;
        writeIndex++;
        buffer >>= 8;
        bitPosition -= 8;
      }
    }

    // After loop, if there are remaining bits in the buffer, write the last partial byte
    if (bitPosition > 0) {
      output[writeIndex] = buffer & 0xff;
      writeIndex++;
    }

    // Return the relevant part of the output array (from 0 to writeIndex)
    return output.subarray(0, writeIndex);
  },
};

function createAllocator(): (size: number) => Uint8Array {
  var currentBuffer = new Uint8Array(256);
  var currentSize = 256;

  return (size: number) => {
    if (currentSize < size) {
      currentBuffer = new Uint8Array(size);
      currentSize = size;
    }
    return currentBuffer;
  };
}
