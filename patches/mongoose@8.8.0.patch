diff --git a/types/aggregate.d.ts b/types/aggregate.d.ts
index 29b4776833e4b2b63b4c0f488a0b57ec1e49e498..a261f642ba33cd5358b5205074a62913d20d9e35 100644
--- a/types/aggregate.d.ts
+++ b/types/aggregate.d.ts
@@ -1,10 +1,12 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   /** Extract generic type from Aggregate class */
   type AggregateExtract<P> = P extends Aggregate<infer T> ? T : never;
 
-  interface AggregateOptions extends Omit<mongodb.AggregateOptions, 'session'>, SessionOption {
+  interface AggregateOptions
+    extends Omit<mongodb.AggregateOptions, 'session'>,
+      SessionOption {
     [key: string]: any;
   }
 
@@ -62,7 +64,6 @@ declare module 'mongoose' {
      */
     cursor<DocType = any>(options?: Record<string, unknown>): Cursor<DocType>;
 
-
     /** Executes the aggregate pipeline on the currently bound Model. */
     exec(): Promise<ResultType>;
 
@@ -133,10 +134,16 @@ declare module 'mongoose' {
     readConcern(level: string): this;
 
     /** Appends a new $redact operator to this aggregate pipeline. */
-    redact(expression: PipelineStage.Redact['$redact'], thenExpr: '$$DESCEND' | '$$PRUNE' | '$$KEEP' | AnyObject, elseExpr: '$$DESCEND' | '$$PRUNE' | '$$KEEP' | AnyObject): this;
+    redact(
+      expression: PipelineStage.Redact['$redact'],
+      thenExpr: '$$DESCEND' | '$$PRUNE' | '$$KEEP' | AnyObject,
+      elseExpr: '$$DESCEND' | '$$PRUNE' | '$$KEEP' | AnyObject,
+    ): this;
 
     /** Appends a new $replaceRoot operator to this aggregate pipeline. */
-    replaceRoot(newRoot: PipelineStage.ReplaceRoot['$replaceRoot']['newRoot'] | string): this;
+    replaceRoot(
+      newRoot: PipelineStage.ReplaceRoot['$replaceRoot']['newRoot'] | string,
+    ): this;
 
     /**
      * Helper for [Atlas Text Search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)'s
@@ -160,7 +167,9 @@ declare module 'mongoose' {
     skip(num: PipelineStage.Skip['$skip']): this;
 
     /** Appends a new $sort operator to this aggregate pipeline. */
-    sort(arg: string | Record<string, SortValues> | PipelineStage.Sort['$sort']): this;
+    sort(
+      arg: string | Record<string, SortValues> | PipelineStage.Sort['$sort'],
+    ): this;
 
     /** Provides promise for aggregate. */
     then: Promise<ResultType>['then'];
diff --git a/types/callback.d.ts b/types/callback.d.ts
index 370379ab4bfc22348d7a5b732878d82a2675ed96..1c15814386d582b2625925d927aa503ba8b41740 100644
--- a/types/callback.d.ts
+++ b/types/callback.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   type CallbackError = NativeError | null;
 
   type Callback<T = any> = (error: CallbackError, result: T) => void;
diff --git a/types/collection.d.ts b/types/collection.d.ts
index 14a09ba3784e93d21be60157b95408ef5ed9c93c..335130fe671c0d0f08adfdb4d0bae77313011cb5 100644
--- a/types/collection.d.ts
+++ b/types/collection.d.ts
@@ -1,10 +1,11 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   /*
    * section collection.js
    */
-  interface CollectionBase<T extends mongodb.Document> extends mongodb.Collection<T> {
+  interface CollectionBase<T extends mongodb.Document>
+    extends mongodb.Collection<T> {
     /*
      * Abstract methods. Some of these are already defined on the
      * mongodb.Collection interface so they've been commented out.
@@ -24,7 +25,8 @@ declare module 'mongoose' {
   /*
    * section drivers/node-mongodb-native/collection.js
    */
-  interface Collection<T extends mongodb.Document = mongodb.Document> extends CollectionBase<T> {
+  interface Collection<T extends mongodb.Document = mongodb.Document>
+    extends CollectionBase<T> {
     /**
      * Collection constructor
      * @param name name of the collection
@@ -32,11 +34,17 @@ declare module 'mongoose' {
      * @param opts optional collection options
      */
     // eslint-disable-next-line @typescript-eslint/no-misused-new
-    new(name: string, conn: Connection, opts?: any): Collection<T>;
+    new (name: string, conn: Connection, opts?: any): Collection<T>;
     /** Formatter for debug print args */
     $format(arg: any, color?: boolean, shell?: boolean): string;
     /** Debug print helper */
-    $print(name: string, i: string | number, args: any[], color?: boolean, shell?: boolean): void;
+    $print(
+      name: string,
+      i: string | number,
+      args: any[],
+      color?: boolean,
+      shell?: boolean,
+    ): void;
     /** Retrieves information about this collections indexes. */
     getIndexes(): ReturnType<mongodb.Collection<T>['indexInformation']>;
   }
diff --git a/types/connection.d.ts b/types/connection.d.ts
index e37914bdb4f5f7f79997e1ef56fac68f975de2f2..21fe96340157d15a4b6278dcd2c9c1c1c720a718 100644
--- a/types/connection.d.ts
+++ b/types/connection.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
   import events = require('events');
 
@@ -69,7 +69,10 @@ declare module 'mongoose' {
     destroy(force?: boolean): Promise<void>;
 
     /** Retrieves a collection, creating it if not cached. */
-    collection<T extends AnyObject = AnyObject>(name: string, options?: mongodb.CreateCollectionOptions): Collection<T>;
+    collection<T extends AnyObject = AnyObject>(
+      name: string,
+      options?: mongodb.CreateCollectionOptions,
+    ): Collection<T>;
 
     /** A hash of the collections associated with this connection */
     readonly collections: { [index: string]: Collection };
@@ -85,12 +88,17 @@ declare module 'mongoose' {
      * with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/)
      * and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.
      */
-    createCollection<T extends AnyObject = AnyObject>(name: string, options?: mongodb.CreateCollectionOptions): Promise<mongodb.Collection<T>>;
+    createCollection<T extends AnyObject = AnyObject>(
+      name: string,
+      options?: mongodb.CreateCollectionOptions,
+    ): Promise<mongodb.Collection<T>>;
 
     /**
      * https://mongoosejs.com/docs/api/connection.html#Connection.prototype.createCollections()
      */
-    createCollections(continueOnError?: boolean): Promise<Record<string, Error | mongodb.Collection<any>>>;
+    createCollections(
+      continueOnError?: boolean,
+    ): Promise<Record<string, Error | mongodb.Collection<any>>>;
 
     /**
      * Removes the model named `name` from this connection, if it exists. You can
@@ -156,25 +164,32 @@ declare module 'mongoose' {
       name: string,
       schema?: TSchema,
       collection?: string,
-      options?: CompileModelOptions
+      options?: CompileModelOptions,
     ): Model<
-    InferSchemaType<TSchema>,
-    ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
-    ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
-    {},
-    HydratedDocument<
-    InferSchemaType<TSchema>,
-    ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
-    ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
-    >,
-    TSchema> & ObtainSchemaGeneric<TSchema, 'TStaticMethods'>;
+      InferSchemaType<TSchema>,
+      ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
+      ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
+      {},
+      HydratedDocument<
+        InferSchemaType<TSchema>,
+        ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
+        ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
+      >,
+      TSchema
+    > &
+      ObtainSchemaGeneric<TSchema, 'TStaticMethods'>;
     model<T, U, TQueryHelpers = {}>(
       name: string,
       schema?: Schema<T, any, any, TQueryHelpers, any, any, any>,
       collection?: string,
-      options?: CompileModelOptions
+      options?: CompileModelOptions,
     ): U;
-    model<T>(name: string, schema?: Schema<T, any, any>, collection?: string, options?: CompileModelOptions): Model<T>;
+    model<T>(
+      name: string,
+      schema?: Schema<T, any, any>,
+      collection?: string,
+      options?: CompileModelOptions,
+    ): Model<T>;
 
     /** Returns an array of model names created on this connection. */
     modelNames(): Array<string>;
@@ -195,7 +210,10 @@ declare module 'mongoose' {
     readonly port: number;
 
     /** Declares a plugin executed on all schemas you pass to `conn.model()` */
-    plugin<S extends Schema = Schema, O = AnyObject>(fn: (schema: S, opts?: any) => void, opts?: O): Connection;
+    plugin<S extends Schema = Schema, O = AnyObject>(
+      fn: (schema: S, opts?: any) => void,
+      opts?: O,
+    ): Connection;
 
     /** The plugins that will be applied to all models created on this connection. */
     plugins: Array<any>;
@@ -234,7 +252,9 @@ declare module 'mongoose' {
      * the model's schema except the `_id` index, and build any indexes that
      * are in your schema but not in MongoDB.
      */
-    syncIndexes(options?: SyncIndexesOptions): Promise<ConnectionSyncIndexesResult>;
+    syncIndexes(
+      options?: SyncIndexesOptions,
+    ): Promise<ConnectionSyncIndexesResult>;
 
     /**
      * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function
@@ -242,18 +262,28 @@ declare module 'mongoose' {
      * async function executes successfully and attempt to retry if
      * there was a retryable error.
      */
-    transaction<ReturnType = unknown>(fn: (session: mongodb.ClientSession) => Promise<ReturnType>, options?: mongodb.TransactionOptions): Promise<ReturnType>;
+    transaction<ReturnType = unknown>(
+      fn: (session: mongodb.ClientSession) => Promise<ReturnType>,
+      options?: mongodb.TransactionOptions,
+    ): Promise<ReturnType>;
 
     /** Switches to a different database using the same connection pool. */
-    useDb(name: string, options?: { useCache?: boolean, noListener?: boolean }): Connection;
+    useDb(
+      name: string,
+      options?: { useCache?: boolean; noListener?: boolean },
+    ): Connection;
 
     /** The username specified in the URI */
     readonly user: string;
 
     /** Watches the entire underlying database for changes. Similar to [`Model.watch()`](/docs/api/model.html#model_Model-watch). */
-    watch<ResultType extends mongodb.Document = any>(pipeline?: Array<any>, options?: mongodb.ChangeStreamOptions): mongodb.ChangeStream<ResultType>;
-
-    withSession<T = any>(executor: (session: ClientSession) => Promise<T>): Promise<T>;
+    watch<ResultType extends mongodb.Document = any>(
+      pipeline?: Array<any>,
+      options?: mongodb.ChangeStreamOptions,
+    ): mongodb.ChangeStream<ResultType>;
+
+    withSession<T = any>(
+      executor: (session: ClientSession) => Promise<T>,
+    ): Promise<T>;
   }
-
 }
diff --git a/types/cursor.d.ts b/types/cursor.d.ts
index 268bb8f67837be34d8e5bf6e7c46e8c34d95b320..09fb03d652a9e5fdf680ae9b131a8cb4f7985e8a 100644
--- a/types/cursor.d.ts
+++ b/types/cursor.d.ts
@@ -1,8 +1,12 @@
-declare module 'mongoose' {
-
+declare module 'mongoose-v8' {
   import stream = require('stream');
 
-  type CursorFlag = 'tailable' | 'oplogReplay' | 'noCursorTimeout' | 'awaitData' | 'partial';
+  type CursorFlag =
+    | 'tailable'
+    | 'oplogReplay'
+    | 'noCursorTimeout'
+    | 'awaitData'
+    | 'partial';
 
   interface EachAsyncOptions {
     parallel?: number;
@@ -45,14 +49,22 @@ declare module 'mongoose' {
      * will wait for the promise to resolve before iterating on to the next one.
      * Returns a promise that resolves when done.
      */
-    eachAsync(fn: (doc: DocType[], i: number) => any, options: EachAsyncOptions & { batchSize: number }): Promise<void>;
-    eachAsync(fn: (doc: DocType, i: number) => any, options?: EachAsyncOptions): Promise<void>;
+    eachAsync(
+      fn: (doc: DocType[], i: number) => any,
+      options: EachAsyncOptions & { batchSize: number },
+    ): Promise<void>;
+    eachAsync(
+      fn: (doc: DocType, i: number) => any,
+      options?: EachAsyncOptions,
+    ): Promise<void>;
 
     /**
      * Registers a transform function which subsequently maps documents retrieved
      * via the streams interface or `.next()`
      */
-    map<ResultType>(fn: (res: DocType) => ResultType): Cursor<ResultType, Options>;
+    map<ResultType>(
+      fn: (res: DocType) => ResultType,
+    ): Cursor<ResultType, Options>;
 
     /**
      * Get the next document from this cursor. Will return `null` when there are
diff --git a/types/document.d.ts b/types/document.d.ts
index e52169dfca40a3fae26b2d57dbc0a242e94d4638..b91df1c0762dcfd177e426b54598666bb7ae9b1d 100644
--- a/types/document.d.ts
+++ b/types/document.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   /** A list of paths to skip. If set, Mongoose will validate every modified path that is not in this list. */
@@ -25,7 +25,10 @@ declare module 'mongoose' {
     _id: T;
 
     /** Assert that a given path or paths is populated. Throws an error if not populated. */
-    $assertPopulated<Paths = {}>(path: string | string[], values?: Partial<Paths>): Omit<this, keyof Paths> & Paths;
+    $assertPopulated<Paths = {}>(
+      path: string | string[],
+      values?: Partial<Paths>,
+    ): Omit<this, keyof Paths> & Paths;
 
     /** Clear the document's modified paths. */
     $clearModifiedPaths(): this;
@@ -106,8 +109,17 @@ declare module 'mongoose' {
     $session(session?: ClientSession | null): ClientSession | null;
 
     /** Alias for `set()`, used internally to avoid conflicts */
-    $set(path: string | Record<string, any>, val: any, type: any, options?: DocumentSetOptions): this;
-    $set(path: string | Record<string, any>, val: any, options?: DocumentSetOptions): this;
+    $set(
+      path: string | Record<string, any>,
+      val: any,
+      type: any,
+      options?: DocumentSetOptions,
+    ): this;
+    $set(
+      path: string | Record<string, any>,
+      val: any,
+      options?: DocumentSetOptions,
+    ): this;
     $set(value: string | Record<string, any>): this;
 
     /** Set this property to add additional query filters when Mongoose saves this document and `isNew` is false. */
@@ -123,7 +135,9 @@ declare module 'mongoose' {
     db: Connection;
 
     /** Removes this document from the db. */
-    deleteOne(options?: QueryOptions): QueryWithHelpers<
+    deleteOne(
+      options?: QueryOptions,
+    ): QueryWithHelpers<
       mongodb.DeleteResult,
       this,
       TQueryHelpers,
@@ -157,7 +171,11 @@ declare module 'mongoose' {
     errors?: Error.ValidationError;
 
     /** Returns the value of a path. */
-    get<T extends keyof DocType>(path: T, type?: any, options?: any): DocType[T];
+    get<T extends keyof DocType>(
+      path: T,
+      type?: any,
+      options?: any,
+    ): DocType[T];
     get(path: string, type?: any, options?: any): any;
 
     /**
@@ -173,15 +191,25 @@ declare module 'mongoose' {
     increment(): this;
 
     /**
-    * Initializes the document without setters or marking anything modified.
-    * Called internally after a document is returned from mongodb. Normally,
-    * you do **not** need to call this function on your own.
-    */
+     * Initializes the document without setters or marking anything modified.
+     * Called internally after a document is returned from mongodb. Normally,
+     * you do **not** need to call this function on your own.
+     */
     init(obj: AnyObject, opts?: AnyObject): this;
 
     /** Marks a path as invalid, causing validation to fail. */
-    invalidate<T extends keyof DocType>(path: T, errorMsg: string | NativeError, value?: any, kind?: string): NativeError | null;
-    invalidate(path: string, errorMsg: string | NativeError, value?: any, kind?: string): NativeError | null;
+    invalidate<T extends keyof DocType>(
+      path: T,
+      errorMsg: string | NativeError,
+      value?: any,
+      kind?: string,
+    ): NativeError | null;
+    invalidate(
+      path: string,
+      errorMsg: string | NativeError,
+      value?: any,
+      kind?: string,
+    ): NativeError | null;
 
     /** Returns true if `path` was directly set and modified, else false. */
     isDirectModified<T extends keyof DocType>(path: T | Array<T>): boolean;
@@ -199,8 +227,14 @@ declare module 'mongoose' {
      * Returns true if any of the given paths are modified, else false. If no arguments, returns `true` if any path
      * in this document is modified.
      */
-    isModified<T extends keyof DocType>(path?: T | Array<T>, options?: { ignoreAtomics?: boolean } | null): boolean;
-    isModified(path?: string | Array<string>, options?: { ignoreAtomics?: boolean } | null): boolean;
+    isModified<T extends keyof DocType>(
+      path?: T | Array<T>,
+      options?: { ignoreAtomics?: boolean } | null,
+    ): boolean;
+    isModified(
+      path?: string | Array<string>,
+      options?: { ignoreAtomics?: boolean } | null,
+    ): boolean;
 
     /** Boolean flag specifying if the document is new. */
     isNew: boolean;
@@ -234,14 +268,25 @@ declare module 'mongoose' {
     $parent(): Document | undefined;
 
     /** Populates document references. */
-    populate<Paths = {}>(path: string | PopulateOptions | (string | PopulateOptions)[]): Promise<MergeType<this, Paths>>;
-    populate<Paths = {}>(path: string, select?: string | AnyObject, model?: Model<any>, match?: AnyObject, options?: PopulateOptions): Promise<MergeType<this, Paths>>;
+    populate<Paths = {}>(
+      path: string | PopulateOptions | (string | PopulateOptions)[],
+    ): Promise<MergeType<this, Paths>>;
+    populate<Paths = {}>(
+      path: string,
+      select?: string | AnyObject,
+      model?: Model<any>,
+      match?: AnyObject,
+      options?: PopulateOptions,
+    ): Promise<MergeType<this, Paths>>;
 
     /** Gets _id(s) used during population of the given `path`. If the path was not populated, returns `undefined`. */
     populated(path: string): any;
 
     /** Sends a replaceOne command with this document `_id` as the query selector. */
-    replaceOne(replacement?: AnyObject, options?: QueryOptions | null): Query<any, this>;
+    replaceOne(
+      replacement?: AnyObject,
+      options?: QueryOptions | null,
+    ): Query<any, this>;
 
     /** Saves this document by inserting a new document into the database if [document.isNew](/docs/api/document.html#document_Document-isNew) is `true`, or sends an [updateOne](/docs/api/document.html#document_Document-updateOne) operation with just the modified paths if `isNew` is `false`. */
     save(options?: SaveOptions): Promise<this>;
@@ -250,23 +295,63 @@ declare module 'mongoose' {
     schema: Schema;
 
     /** Sets the value of a path, or many paths. */
-    set<T extends keyof DocType>(path: T, val: DocType[T], type: any, options?: DocumentSetOptions): this;
-    set(path: string | Record<string, any>, val: any, type: any, options?: DocumentSetOptions): this;
-    set(path: string | Record<string, any>, val: any, options?: DocumentSetOptions): this;
+    set<T extends keyof DocType>(
+      path: T,
+      val: DocType[T],
+      type: any,
+      options?: DocumentSetOptions,
+    ): this;
+    set(
+      path: string | Record<string, any>,
+      val: any,
+      type: any,
+      options?: DocumentSetOptions,
+    ): this;
+    set(
+      path: string | Record<string, any>,
+      val: any,
+      options?: DocumentSetOptions,
+    ): this;
     set(value: string | Record<string, any>): this;
 
     /** The return value of this method is used in calls to JSON.stringify(doc). */
-    toJSON(options?: ToObjectOptions & { flattenMaps?: true, flattenObjectIds?: false }): FlattenMaps<Require_id<DocType>>;
-    toJSON(options: ToObjectOptions & { flattenObjectIds: false }): FlattenMaps<Require_id<DocType>>;
-    toJSON(options: ToObjectOptions & { flattenObjectIds: true }): ObjectIdToString<FlattenMaps<Require_id<DocType>>>;
-    toJSON(options: ToObjectOptions & { flattenMaps: false }): Require_id<DocType>;
-    toJSON(options: ToObjectOptions & { flattenMaps: false; flattenObjectIds: true }): ObjectIdToString<Require_id<DocType>>;
-
-    toJSON<T = Require_id<DocType>>(options?: ToObjectOptions & { flattenMaps?: true, flattenObjectIds?: false }): FlattenMaps<T>;
-    toJSON<T = Require_id<DocType>>(options: ToObjectOptions & { flattenObjectIds: false }): FlattenMaps<T>;
-    toJSON<T = Require_id<DocType>>(options: ToObjectOptions & { flattenObjectIds: true }): ObjectIdToString<FlattenMaps<T>>;
-    toJSON<T = Require_id<DocType>>(options: ToObjectOptions & { flattenMaps: false }): T;
-    toJSON<T = Require_id<DocType>>(options: ToObjectOptions & { flattenMaps: false; flattenObjectIds: true }): ObjectIdToString<T>;
+    toJSON(
+      options?: ToObjectOptions & {
+        flattenMaps?: true;
+        flattenObjectIds?: false;
+      },
+    ): FlattenMaps<Require_id<DocType>>;
+    toJSON(
+      options: ToObjectOptions & { flattenObjectIds: false },
+    ): FlattenMaps<Require_id<DocType>>;
+    toJSON(
+      options: ToObjectOptions & { flattenObjectIds: true },
+    ): ObjectIdToString<FlattenMaps<Require_id<DocType>>>;
+    toJSON(
+      options: ToObjectOptions & { flattenMaps: false },
+    ): Require_id<DocType>;
+    toJSON(
+      options: ToObjectOptions & { flattenMaps: false; flattenObjectIds: true },
+    ): ObjectIdToString<Require_id<DocType>>;
+
+    toJSON<T = Require_id<DocType>>(
+      options?: ToObjectOptions & {
+        flattenMaps?: true;
+        flattenObjectIds?: false;
+      },
+    ): FlattenMaps<T>;
+    toJSON<T = Require_id<DocType>>(
+      options: ToObjectOptions & { flattenObjectIds: false },
+    ): FlattenMaps<T>;
+    toJSON<T = Require_id<DocType>>(
+      options: ToObjectOptions & { flattenObjectIds: true },
+    ): ObjectIdToString<FlattenMaps<T>>;
+    toJSON<T = Require_id<DocType>>(
+      options: ToObjectOptions & { flattenMaps: false },
+    ): T;
+    toJSON<T = Require_id<DocType>>(
+      options: ToObjectOptions & { flattenMaps: false; flattenObjectIds: true },
+    ): ObjectIdToString<T>;
 
     /** Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)). */
     toObject(options?: ToObjectOptions): Require_id<DocType>;
@@ -277,16 +362,34 @@ declare module 'mongoose' {
     unmarkModified(path: string): void;
 
     /** Sends an updateOne command with this document `_id` as the query selector. */
-    updateOne(update?: UpdateQuery<this> | UpdateWithAggregationPipeline, options?: QueryOptions | null): Query<any, this>;
+    updateOne(
+      update?: UpdateQuery<this> | UpdateWithAggregationPipeline,
+      options?: QueryOptions | null,
+    ): Query<any, this>;
 
     /** Executes registered validation rules for this document. */
-    validate<T extends keyof DocType>(pathsToValidate?: T | T[], options?: AnyObject): Promise<void>;
-    validate(pathsToValidate?: pathsToValidate, options?: AnyObject): Promise<void>;
+    validate<T extends keyof DocType>(
+      pathsToValidate?: T | T[],
+      options?: AnyObject,
+    ): Promise<void>;
+    validate(
+      pathsToValidate?: pathsToValidate,
+      options?: AnyObject,
+    ): Promise<void>;
     validate(options: { pathsToSkip?: pathsToSkip }): Promise<void>;
 
     /** Executes registered validation rules (skipping asynchronous validators) for this document. */
-    validateSync(options: { pathsToSkip?: pathsToSkip, [k: string]: any }): Error.ValidationError | null;
-    validateSync<T extends keyof DocType>(pathsToValidate?: T | T[], options?: AnyObject): Error.ValidationError | null;
-    validateSync(pathsToValidate?: pathsToValidate, options?: AnyObject): Error.ValidationError | null;
+    validateSync(options: {
+      pathsToSkip?: pathsToSkip;
+      [k: string]: any;
+    }): Error.ValidationError | null;
+    validateSync<T extends keyof DocType>(
+      pathsToValidate?: T | T[],
+      options?: AnyObject,
+    ): Error.ValidationError | null;
+    validateSync(
+      pathsToValidate?: pathsToValidate,
+      options?: AnyObject,
+    ): Error.ValidationError | null;
   }
 }
diff --git a/types/error.d.ts b/types/error.d.ts
index 3fec7c41399f6b4cf7b5330fcc36b7841baf5347..45d1b741c56b4e7b9d6e106a05daef021bdef0e3 100644
--- a/types/error.d.ts
+++ b/types/error.d.ts
@@ -1,6 +1,6 @@
-declare class NativeError extends global.Error { }
+declare class NativeError extends global.Error {}
 
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   type CastError = Error.CastError;
@@ -17,10 +17,9 @@ declare module 'mongoose' {
     static Messages: any;
   }
 
-  class Error extends MongooseError { }
+  class Error extends MongooseError {}
 
   namespace Error {
-
     export class CastError extends MongooseError {
       name: 'CastError';
       stringValue: string;
@@ -29,13 +28,25 @@ declare module 'mongoose' {
       path: string;
       reason?: NativeError | null;
 
-      constructor(type: string, value: any, path: string, reason?: NativeError, schemaType?: SchemaType);
+      constructor(
+        type: string,
+        value: any,
+        path: string,
+        reason?: NativeError,
+        schemaType?: SchemaType,
+      );
     }
     export class SyncIndexesError extends MongooseError {
       name: 'SyncIndexesError';
       errors?: Record<string, mongodb.MongoServerError>;
 
-      constructor(type: string, value: any, path: string, reason?: NativeError, schemaType?: SchemaType);
+      constructor(
+        type: string,
+        value: any,
+        path: string,
+        reason?: NativeError,
+        schemaType?: SchemaType,
+      );
     }
 
     export class DivergentArrayError extends MongooseError {
@@ -97,11 +108,11 @@ declare module 'mongoose' {
     export class ValidatorError extends MongooseError {
       name: 'ValidatorError';
       properties: {
-        message: string,
-        type?: string,
-        path?: string,
-        value?: any,
-        reason?: any
+        message: string;
+        type?: string;
+        path?: string;
+        value?: any;
+        reason?: any;
       };
       kind: string;
       path: string;
@@ -109,11 +120,11 @@ declare module 'mongoose' {
       reason?: MongooseError | null;
 
       constructor(properties: {
-        message?: string,
-        type?: string,
-        path?: string,
-        value?: any,
-        reason?: any
+        message?: string;
+        type?: string;
+        path?: string;
+        value?: any;
+        reason?: any;
       });
     }
 
@@ -122,7 +133,11 @@ declare module 'mongoose' {
       version: number;
       modifiedPaths: Array<string>;
 
-      constructor(doc: Document, currentVersion: number, modifiedPaths: Array<string>);
+      constructor(
+        doc: Document,
+        currentVersion: number,
+        modifiedPaths: Array<string>,
+      );
     }
 
     export class StrictPopulateError extends MongooseError {
diff --git a/types/expressions.d.ts b/types/expressions.d.ts
index d3efdd81c06a27d80a99ad63fcb0e3b205d8f31a..ba2bc24193607909869e961a89cf306f4fc01078 100644
--- a/types/expressions.d.ts
+++ b/types/expressions.d.ts
@@ -1,20 +1,16 @@
-declare module 'mongoose' {
-
+declare module 'mongoose-v8' {
   /**
    * [Expressions reference](https://www.mongodb.com/docs/manual/meta/aggregation-quick-reference/#expressions)
    */
   type AggregationVariables =
-    SpecialPathVariables |
-    '$$NOW' |
-    '$$CLUSTER_TIME' |
-    '$$DESCEND' |
-    '$$PRUNE' |
-    '$$KEEP';
-
-  type SpecialPathVariables =
-    '$$ROOT' |
-    '$$CURRENT' |
-    '$$REMOVE';
+    | SpecialPathVariables
+    | '$$NOW'
+    | '$$CLUSTER_TIME'
+    | '$$DESCEND'
+    | '$$PRUNE'
+    | '$$KEEP';
+
+  type SpecialPathVariables = '$$ROOT' | '$$CURRENT' | '$$REMOVE';
 
   export namespace Expression {
     export interface Abs {
@@ -250,7 +246,6 @@ declare module 'mongoose' {
     }
 
     export interface Atanh {
-
       /**
        * Returns the inverse hyperbolic tangent (hyperbolic arc tangent) of a value in radians.
        *
@@ -399,7 +394,7 @@ declare module 'mongoose' {
          * - sunday (or sun)
          */
         startOfWeek?: StringExpression<StartOfWeek>;
-      }
+      };
     }
 
     // TODO: Can be done better
@@ -697,7 +692,7 @@ declare module 'mongoose' {
          * - sunday (or sun)
          */
         startOfWeek?: StringExpression<StartOfWeek>;
-      }
+      };
     }
 
     export interface DayOfMonth {
@@ -706,16 +701,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/dayOfMonth/#mongodb-expression-exp.-dayOfMonth
        */
-      $dayOfMonth: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $dayOfMonth:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface DayOfWeek {
@@ -724,16 +721,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/dayOfWeek/#mongodb-expression-exp.-dayOfWeek
        */
-      $dayOfWeek: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $dayOfWeek:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface DayOfYear {
@@ -742,16 +741,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/dayOfYear/#mongodb-expression-exp.-dayOfYear
        */
-      $dayOfYear: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $dayOfYear:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface Hour {
@@ -760,16 +761,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/hour/#mongodb-expression-exp.-hour
        */
-      $hour: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $hour:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface IsoDayOfWeek {
@@ -779,16 +782,18 @@ declare module 'mongoose' {
        * @version 3.4
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/isoDayOfWeek/#mongodb-expression-exp.-isoDayOfWeek
        */
-      $isoDayOfWeek: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $isoDayOfWeek:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface IsoWeek {
@@ -798,16 +803,18 @@ declare module 'mongoose' {
        * @version 3.4
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/isoWeek/#mongodb-expression-exp.-isoWeek
        */
-      $isoWeek: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $isoWeek:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface IsoWeekYear {
@@ -817,16 +824,18 @@ declare module 'mongoose' {
        * @version 3.4
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/isoWeekYear/#mongodb-expression-exp.-isoWeekYear
        */
-      $isoWeekYear: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $isoWeekYear:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface Millisecond {
@@ -835,16 +844,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/millisecond/#mongodb-expression-exp.-millisecond
        */
-      $millisecond: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $millisecond:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface Minute {
@@ -853,16 +864,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/minute/#mongodb-expression-exp.-minute
        */
-      $minute: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $minute:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface Month {
@@ -871,16 +884,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/month/#mongodb-expression-exp.-month
        */
-      $month: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $month:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface Second {
@@ -889,16 +904,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/second/#mongodb-expression-exp.-second
        */
-      $second: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $second:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface ToDate {
@@ -917,16 +934,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/week/#mongodb-expression-exp.-week
        */
-      $week: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $week:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface Year {
@@ -935,16 +954,18 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/year/#mongodb-expression-exp.-year
        */
-      $year: DateExpression | {
-        /**
-         * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
-         */
-        date: DateExpression;
-        /**
-         * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
-         */
-        timezone?: tzExpression;
-      };
+      $year:
+        | DateExpression
+        | {
+            /**
+             * The date to which the operator is applied. <dateExpression> must be a valid expression that resolves to a Date, a Timestamp, or an ObjectID.
+             */
+            date: DateExpression;
+            /**
+             * The timezone of the operation result. <tzExpression> must be a valid expression that resolves to a string formatted as either an Olson Timezone Identifier or a UTC Offset. If no timezone is provided, the result is displayed in UTC.
+             */
+            timezone?: tzExpression;
+          };
     }
 
     export interface And {
@@ -980,7 +1001,10 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/cmp/#mongodb-expression-exp.-cmp
        */
-      $cmp: [Record<string, AnyExpression> | Expression, Record<string, AnyExpression> | Expression];
+      $cmp: [
+        Record<string, AnyExpression> | Expression,
+        Record<string, AnyExpression> | Expression,
+      ];
     }
 
     export interface Eq {
@@ -1043,7 +1067,9 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/cond/#mongodb-expression-exp.-cond
        */
-      $cond: { if: Expression, then: AnyExpression, else: AnyExpression } | [BooleanExpression, AnyExpression, AnyExpression];
+      $cond:
+        | { if: Expression; then: AnyExpression; else: AnyExpression }
+        | [BooleanExpression, AnyExpression, AnyExpression];
     }
 
     export interface IfNull {
@@ -1067,7 +1093,7 @@ declare module 'mongoose' {
          * - $case
          * - $then
          */
-        branches: { case: Expression, then: Expression }[];
+        branches: { case: Expression; then: Expression }[];
         /**
          * The path to take if no branch case expression evaluates to true.
          *
@@ -1137,7 +1163,7 @@ declare module 'mongoose' {
          * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/filter/#using-the-limit-field
          */
         limit?: NumberExpression;
-      }
+      };
     }
 
     export interface First {
@@ -1167,7 +1193,10 @@ declare module 'mongoose' {
        * @version 3.4
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/indexOfArray/#mongodb-expression-exp.-indexOfArray
        */
-      $indexOfArray: [ArrayExpression, Expression] | [ArrayExpression, Expression, NumberExpression] | [ArrayExpression, Expression, NumberExpression, NumberExpression];
+      $indexOfArray:
+        | [ArrayExpression, Expression]
+        | [ArrayExpression, Expression, NumberExpression]
+        | [ArrayExpression, Expression, NumberExpression, NumberExpression];
     }
 
     export interface IsArray {
@@ -1197,7 +1226,7 @@ declare module 'mongoose' {
        * @version 5.3
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/linearFill
        */
-      $linearFill: Expression
+      $linearFill: Expression;
     }
 
     export interface Locf {
@@ -1207,7 +1236,7 @@ declare module 'mongoose' {
        * @version 5.2
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/locf
        */
-      $locf: Expression
+      $locf: Expression;
     }
 
     export interface Map {
@@ -1248,7 +1277,9 @@ declare module 'mongoose' {
        *
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/range/#mongodb-expression-exp.-range
        */
-      $range: [NumberExpression, NumberExpression] | [NumberExpression, NumberExpression, NumberExpression];
+      $range:
+        | [NumberExpression, NumberExpression]
+        | [NumberExpression, NumberExpression, NumberExpression];
     }
 
     export interface Reduce {
@@ -1308,7 +1339,9 @@ declare module 'mongoose' {
        * @version 3.2
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/slice/#mongodb-expression-exp.-slice
        */
-      $slice: [ArrayExpression, NumberExpression] | [ArrayExpression, NumberExpression, NumberExpression];
+      $slice:
+        | [ArrayExpression, NumberExpression]
+        | [ArrayExpression, NumberExpression, NumberExpression];
     }
 
     export interface Zip {
@@ -1360,7 +1393,15 @@ declare module 'mongoose' {
        * @version 3.4
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/indexOfBytes/#mongodb-expression-exp.-indexOfBytes
        */
-      $indexOfBytes: [StringExpression, StringExpression] | [StringExpression, StringExpression, NumberExpression] | [StringExpression, StringExpression, NumberExpression, NumberExpression];
+      $indexOfBytes:
+        | [StringExpression, StringExpression]
+        | [StringExpression, StringExpression, NumberExpression]
+        | [
+            StringExpression,
+            StringExpression,
+            NumberExpression,
+            NumberExpression,
+          ];
     }
 
     export interface IndexOfCP {
@@ -1370,7 +1411,15 @@ declare module 'mongoose' {
        * @version 3.4
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/indexOfCP/#mongodb-expression-exp.-indexOfCP
        */
-      $indexOfCP: [StringExpression, StringExpression] | [StringExpression, StringExpression, NumberExpression] | [StringExpression, StringExpression, NumberExpression, NumberExpression];
+      $indexOfCP:
+        | [StringExpression, StringExpression]
+        | [StringExpression, StringExpression, NumberExpression]
+        | [
+            StringExpression,
+            StringExpression,
+            NumberExpression,
+            NumberExpression,
+          ];
     }
 
     export interface Ltrim {
@@ -1728,7 +1777,6 @@ declare module 'mongoose' {
     }
 
     export interface Literal {
-
       /**
        * Returns a value without parsing. Use for values that the aggregation pipeline may interpret as an
        * expression.
@@ -1739,7 +1787,6 @@ declare module 'mongoose' {
     }
 
     export interface GetField {
-
       /**
        * Returns the value of a specified field from a document. If you don't specify an object, $getField returns
        * the value of the field from $$CURRENT.
@@ -1759,11 +1806,10 @@ declare module 'mongoose' {
          * pipeline ($$CURRENT).
          */
         input?: ObjectExpression | SpecialPathVariables | NullExpression;
-      }
+      };
     }
 
     export interface Rand {
-
       /**
        * Returns a random float between 0 and 1 each time it is called.
        *
@@ -1774,7 +1820,6 @@ declare module 'mongoose' {
     }
 
     export interface SampleRate {
-
       /**
        * Matches a random selection of input documents. The number of documents selected approximates the sample
        * rate expressed as a percentage of the total number of documents.
@@ -1786,18 +1831,20 @@ declare module 'mongoose' {
     }
 
     export interface MergeObjects {
-
       /**
        * Combines multiple documents into a single document.
        *
        * @version 3.6
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/mergeObjects/#mongodb-expression-exp.-mergeObjects
        */
-      $mergeObjects: ObjectExpression | ObjectExpression[] | ArrayExpression | Record<string, string>;
+      $mergeObjects:
+        | ObjectExpression
+        | ObjectExpression[]
+        | ArrayExpression
+        | Record<string, string>;
     }
 
     export interface SetField {
-
       /**
        * Adds, updates, or removes a specified field in a document.
        *
@@ -1819,11 +1866,10 @@ declare module 'mongoose' {
          * The value that you want to assign to field. value can be any valid expression.
          */
         value?: Expression | SpecialPathVariables;
-      }
+      };
     }
 
     export interface UnsetField {
-
       /**
        * Removes a specified field in a document.
        *
@@ -1841,11 +1887,10 @@ declare module 'mongoose' {
          * null, or undefined.
          */
         input?: ObjectExpression | SpecialPathVariables | NullExpression;
-      }
+      };
     }
 
     export interface Let {
-
       /**
        * Binds variables for use in the specified expression, and returns the result of the expression.
        *
@@ -1857,12 +1902,12 @@ declare module 'mongoose' {
          * Assignment block for the variables accessible in the in expression. To assign a variable, specify a
          * string for the variable name and assign a valid expression for the value.
          */
-        vars: { [key: string]: Expression; };
+        vars: { [key: string]: Expression };
         /**
          * The expression to evaluate.
          */
         in: Expression;
-      }
+      };
     }
 
     export interface AllElementsTrue {
@@ -1977,7 +2022,7 @@ declare module 'mongoose' {
          * The language used in the $accumulator code.
          */
         lang: 'js';
-      }
+      };
     }
 
     export interface AddToSet {
@@ -2059,7 +2104,7 @@ declare module 'mongoose' {
          * A string that specifies the time unit.
          */
         unit?: DateUnit;
-      }
+      };
     }
 
     export interface DocumentNumber {
@@ -2080,50 +2125,51 @@ declare module 'mongoose' {
        * @version 5.0
        * @see https://www.mongodb.com/docs/manual/reference/operator/aggregation/expMovingAvg/#mongodb-expression-exp.-expMovingAvg
        */
-      $expMovingAvg: {
-        /**
-         * Specifies the expression to evaluate. Non-numeric expressions are ignored.
-         */
-        input: Expression;
-
-        /**
-         * An integer that specifies the number of historical documents that have a significant mathematical weight in
-         * the exponential moving average calculation, with the most recent documents contributing the most weight.
-         *
-         * You must specify either N or alpha. You cannot specify both.
-         */
-        N: NumberExpression;
-
-        /**
-         * A double that specifies the exponential decay value to use in the exponential moving average calculation. A
-         * higher alpha value assigns a lower mathematical significance to previous results from the calculation.
-         *
-         * You must specify either N or alpha. You cannot specify both.
-         */
-        alpha?: never;
-      } |
-      {
-        /**
-         * Specifies the expression to evaluate. Non-numeric expressions are ignored.
-         */
-        input: Expression;
-
-        /**
-         * An integer that specifies the number of historical documents that have a significant mathematical weight in
-         * the exponential moving average calculation, with the most recent documents contributing the most weight.
-         *
-         * You must specify either N or alpha. You cannot specify both.
-         */
-        N?: never;
-
-        /**
-         * A double that specifies the exponential decay value to use in the exponential moving average calculation. A
-         * higher alpha value assigns a lower mathematical significance to previous results from the calculation.
-         *
-         * You must specify either N or alpha. You cannot specify both.
-         */
-        alpha: NumberExpression;
-      }
+      $expMovingAvg:
+        | {
+            /**
+             * Specifies the expression to evaluate. Non-numeric expressions are ignored.
+             */
+            input: Expression;
+
+            /**
+             * An integer that specifies the number of historical documents that have a significant mathematical weight in
+             * the exponential moving average calculation, with the most recent documents contributing the most weight.
+             *
+             * You must specify either N or alpha. You cannot specify both.
+             */
+            N: NumberExpression;
+
+            /**
+             * A double that specifies the exponential decay value to use in the exponential moving average calculation. A
+             * higher alpha value assigns a lower mathematical significance to previous results from the calculation.
+             *
+             * You must specify either N or alpha. You cannot specify both.
+             */
+            alpha?: never;
+          }
+        | {
+            /**
+             * Specifies the expression to evaluate. Non-numeric expressions are ignored.
+             */
+            input: Expression;
+
+            /**
+             * An integer that specifies the number of historical documents that have a significant mathematical weight in
+             * the exponential moving average calculation, with the most recent documents contributing the most weight.
+             *
+             * You must specify either N or alpha. You cannot specify both.
+             */
+            N?: never;
+
+            /**
+             * A double that specifies the exponential decay value to use in the exponential moving average calculation. A
+             * higher alpha value assigns a lower mathematical significance to previous results from the calculation.
+             *
+             * You must specify either N or alpha. You cannot specify both.
+             */
+            alpha: NumberExpression;
+          };
     }
 
     export interface Integral {
@@ -2144,7 +2190,7 @@ declare module 'mongoose' {
          * A string that specifies the time unit.
          */
         unit?: DateUnit;
-      }
+      };
     }
 
     export interface Max {
@@ -2212,7 +2258,7 @@ declare module 'mongoose' {
          * $setWindowFields stage window. The implicit window contains all the documents in the partition.
          */
         default?: Expression;
-      }
+      };
     }
 
     export interface StdDevPop {
@@ -2248,7 +2294,41 @@ declare module 'mongoose' {
       $sum: number | Expression | Expression[];
     }
 
-    export interface Convert<K extends 'double' | 1 | 'string' | 2 | 'objectId' | 7 | 'bool' | 8 | 'date' | 9 | 'int' | 16 | 'long' | 18 | 'decimal' | 19 = 'double' | 1 | 'string' | 2 | 'objectId' | 7 | 'bool' | 8 | 'date' | 9 | 'int' | 16 | 'long' | 18 | 'decimal' | 19> {
+    export interface Convert<
+      K extends
+        | 'double'
+        | 1
+        | 'string'
+        | 2
+        | 'objectId'
+        | 7
+        | 'bool'
+        | 8
+        | 'date'
+        | 9
+        | 'int'
+        | 16
+        | 'long'
+        | 18
+        | 'decimal'
+        | 19 =
+        | 'double'
+        | 1
+        | 'string'
+        | 2
+        | 'objectId'
+        | 7
+        | 'bool'
+        | 8
+        | 'date'
+        | 9
+        | 'int'
+        | 16
+        | 'long'
+        | 18
+        | 'decimal'
+        | 19,
+    > {
       /**
        * Checks if the specified expression resolves to one of the following numeric
        * - Integer
@@ -2348,16 +2428,16 @@ declare module 'mongoose' {
 
     export interface Top {
       $top: {
-        sortBy: AnyObject,
-        output: Expression
+        sortBy: AnyObject;
+        output: Expression;
       };
     }
 
     export interface TopN {
       $topN: {
-        n: Expression,
-        sortBy: AnyObject,
-        output: Expression
+        n: Expression;
+        sortBy: AnyObject;
+        output: Expression;
       };
     }
 
@@ -2423,308 +2503,292 @@ declare module 'mongoose' {
         /**
          * The language used in the body. You must specify lang: "js".
          */
-        lang: 'js'
+        lang: 'js';
       };
     }
   }
 
   type Path = string;
 
-
   export type Expression =
-    Path |
-    ArithmeticExpressionOperator |
-    ArrayExpressionOperator |
-    BooleanExpressionOperator |
-    ComparisonExpressionOperator |
-    ConditionalExpressionOperator |
-    CustomAggregationExpressionOperator |
-    DataSizeOperator |
-    DateExpressionOperator |
-    LiteralExpressionOperator |
-    MiscellaneousExpressionOperator |
-    ObjectExpressionOperator |
-    SetExpressionOperator |
-    StringExpressionOperator |
-    TextExpressionOperator |
-    TrigonometryExpressionOperator |
-    TypeExpressionOperator |
-    AccumulatorOperator |
-    VariableExpressionOperator |
-    WindowOperator |
-    Expression.Top |
-    Expression.TopN |
-    any;
+    | Path
+    | ArithmeticExpressionOperator
+    | ArrayExpressionOperator
+    | BooleanExpressionOperator
+    | ComparisonExpressionOperator
+    | ConditionalExpressionOperator
+    | CustomAggregationExpressionOperator
+    | DataSizeOperator
+    | DateExpressionOperator
+    | LiteralExpressionOperator
+    | MiscellaneousExpressionOperator
+    | ObjectExpressionOperator
+    | SetExpressionOperator
+    | StringExpressionOperator
+    | TextExpressionOperator
+    | TrigonometryExpressionOperator
+    | TypeExpressionOperator
+    | AccumulatorOperator
+    | VariableExpressionOperator
+    | WindowOperator
+    | Expression.Top
+    | Expression.TopN
+    | any;
 
   export type NullExpression = null;
 
-  export type CodeExpression =
-    string |
-    Function;
+  export type CodeExpression = string | Function;
 
-  export type BinaryExpression =
-    Path;
+  export type BinaryExpression = Path;
 
-  export type FunctionExpression =
-    Expression.Function;
+  export type FunctionExpression = Expression.Function;
 
   export type AnyExpression =
-    ArrayExpression |
-    BooleanExpression |
-    NumberExpression |
-    ObjectExpression |
-    StringExpression |
-    DateExpression |
-    BinaryExpression |
-    FunctionExpression |
-    ObjectIdExpression |
-    ConditionalExpressionOperator |
-    any;
-
-  export type ObjectIdExpression =
-    TypeExpressionOperatorReturningObjectId;
+    | ArrayExpression
+    | BooleanExpression
+    | NumberExpression
+    | ObjectExpression
+    | StringExpression
+    | DateExpression
+    | BinaryExpression
+    | FunctionExpression
+    | ObjectIdExpression
+    | ConditionalExpressionOperator
+    | any;
+
+  export type ObjectIdExpression = TypeExpressionOperatorReturningObjectId;
 
   export type ArrayExpression<T = any> =
-    T[] |
-    Path |
-    ArrayExpressionOperatorReturningAny |
-    ArrayExpressionOperatorReturningArray |
-    StringExpressionOperatorReturningArray |
-    ObjectExpressionOperatorReturningArray |
-    SetExpressionOperatorReturningArray |
-    LiteralExpressionOperatorReturningAny |
-    WindowOperatorReturningArray |
-    CustomAggregationExpressionOperatorReturningAny |
-    WindowOperatorReturningAny;
+    | T[]
+    | Path
+    | ArrayExpressionOperatorReturningAny
+    | ArrayExpressionOperatorReturningArray
+    | StringExpressionOperatorReturningArray
+    | ObjectExpressionOperatorReturningArray
+    | SetExpressionOperatorReturningArray
+    | LiteralExpressionOperatorReturningAny
+    | WindowOperatorReturningArray
+    | CustomAggregationExpressionOperatorReturningAny
+    | WindowOperatorReturningAny;
 
   export type BooleanExpression =
-    boolean |
-    Path |
-    BooleanExpressionOperator |
-    ArrayExpressionOperatorReturningAny |
-    ComparisonExpressionOperatorReturningBoolean |
-    StringExpressionOperatorReturningBoolean |
-    SetExpressionOperatorReturningBoolean |
-    LiteralExpressionOperatorReturningAny |
-    CustomAggregationExpressionOperatorReturningAny |
-    TypeExpressionOperatorReturningBoolean;
+    | boolean
+    | Path
+    | BooleanExpressionOperator
+    | ArrayExpressionOperatorReturningAny
+    | ComparisonExpressionOperatorReturningBoolean
+    | StringExpressionOperatorReturningBoolean
+    | SetExpressionOperatorReturningBoolean
+    | LiteralExpressionOperatorReturningAny
+    | CustomAggregationExpressionOperatorReturningAny
+    | TypeExpressionOperatorReturningBoolean;
 
   export type NumberExpression =
-    number |
-    Path |
-    ArrayExpressionOperatorReturningAny |
-    ArrayExpressionOperatorReturningNumber |
-    ArithmeticExpressionOperator |
-    ComparisonExpressionOperatorReturningNumber |
-    TrigonometryExpressionOperator |
-    MiscellaneousExpressionOperatorReturningNumber |
-    StringExpressionOperatorReturningNumber |
-    LiteralExpressionOperatorReturningAny |
-    ObjectExpressionOperator |
-    SetExpressionOperator |
-    WindowOperatorReturningNumber |
-    WindowOperatorReturningAny |
-    DataSizeOperatorReturningNumber |
-    CustomAggregationExpressionOperatorReturningAny |
-    TypeExpressionOperatorReturningNumber |
-    DateExpression |
-    DateExpressionOperatorReturningNumber;
+    | number
+    | Path
+    | ArrayExpressionOperatorReturningAny
+    | ArrayExpressionOperatorReturningNumber
+    | ArithmeticExpressionOperator
+    | ComparisonExpressionOperatorReturningNumber
+    | TrigonometryExpressionOperator
+    | MiscellaneousExpressionOperatorReturningNumber
+    | StringExpressionOperatorReturningNumber
+    | LiteralExpressionOperatorReturningAny
+    | ObjectExpressionOperator
+    | SetExpressionOperator
+    | WindowOperatorReturningNumber
+    | WindowOperatorReturningAny
+    | DataSizeOperatorReturningNumber
+    | CustomAggregationExpressionOperatorReturningAny
+    | TypeExpressionOperatorReturningNumber
+    | DateExpression
+    | DateExpressionOperatorReturningNumber;
 
   export type ObjectExpression =
-    Path |
-    ArrayExpressionOperatorReturningAny |
-    DateExpressionOperatorReturningObject |
-    StringExpressionOperatorReturningObject |
-    ObjectExpressionOperatorReturningObject |
-    CustomAggregationExpressionOperatorReturningAny |
-    LiteralExpressionOperatorReturningAny;
+    | Path
+    | ArrayExpressionOperatorReturningAny
+    | DateExpressionOperatorReturningObject
+    | StringExpressionOperatorReturningObject
+    | ObjectExpressionOperatorReturningObject
+    | CustomAggregationExpressionOperatorReturningAny
+    | LiteralExpressionOperatorReturningAny;
 
   export type StringExpression<T = string> =
-    Path |
-    ArrayExpressionOperatorReturningAny |
-    DateExpressionOperatorReturningString |
-    StringExpressionOperatorReturningString |
-    LiteralExpressionReturningAny |
-    CustomAggregationExpressionOperatorReturningAny |
-    TypeExpressionOperatorReturningString |
-    T;
+    | Path
+    | ArrayExpressionOperatorReturningAny
+    | DateExpressionOperatorReturningString
+    | StringExpressionOperatorReturningString
+    | LiteralExpressionReturningAny
+    | CustomAggregationExpressionOperatorReturningAny
+    | TypeExpressionOperatorReturningString
+    | T;
 
   export type DateExpression =
-    Path |
-    NativeDate |
-    DateExpressionOperatorReturningDate |
-    TypeExpressionOperatorReturningDate |
-    LiteralExpressionReturningAny;
+    | Path
+    | NativeDate
+    | DateExpressionOperatorReturningDate
+    | TypeExpressionOperatorReturningDate
+    | LiteralExpressionReturningAny;
 
   export type ArithmeticExpressionOperator =
-    Expression.Abs |
-    Expression.Add |
-    Expression.Ceil |
-    Expression.Divide |
-    Expression.Exp |
-    Expression.Floor |
-    Expression.Ln |
-    Expression.Log |
-    Expression.Log10 |
-    Expression.Mod |
-    Expression.Multiply |
-    Expression.Pow |
-    Expression.Round |
-    Expression.Sqrt |
-    Expression.Subtract |
-    Expression.Trunc;
+    | Expression.Abs
+    | Expression.Add
+    | Expression.Ceil
+    | Expression.Divide
+    | Expression.Exp
+    | Expression.Floor
+    | Expression.Ln
+    | Expression.Log
+    | Expression.Log10
+    | Expression.Mod
+    | Expression.Multiply
+    | Expression.Pow
+    | Expression.Round
+    | Expression.Sqrt
+    | Expression.Subtract
+    | Expression.Trunc;
 
   export type ArrayExpressionOperator =
-    ArrayExpressionOperatorReturningAny |
-    ArrayExpressionOperatorReturningBoolean |
-    ArrayExpressionOperatorReturningNumber |
-    ArrayExpressionOperatorReturningObject;
+    | ArrayExpressionOperatorReturningAny
+    | ArrayExpressionOperatorReturningBoolean
+    | ArrayExpressionOperatorReturningNumber
+    | ArrayExpressionOperatorReturningObject;
 
-  export type LiteralExpressionOperator =
-    Expression.Literal;
+  export type LiteralExpressionOperator = Expression.Literal;
 
   export type LiteralExpressionReturningAny =
     LiteralExpressionOperatorReturningAny;
 
-  export type LiteralExpressionOperatorReturningAny =
-    Expression.Literal;
+  export type LiteralExpressionOperatorReturningAny = Expression.Literal;
 
   export type MiscellaneousExpressionOperator =
-    Expression.Rand |
-    Expression.SampleRate;
+    | Expression.Rand
+    | Expression.SampleRate;
 
-  export type MiscellaneousExpressionOperatorReturningNumber =
-    Expression.Rand;
+  export type MiscellaneousExpressionOperatorReturningNumber = Expression.Rand;
 
   export type ArrayExpressionOperatorReturningAny =
-    Expression.ArrayElemAt |
-    Expression.First |
-    Expression.Last |
-    Expression.Reduce;
+    | Expression.ArrayElemAt
+    | Expression.First
+    | Expression.Last
+    | Expression.Reduce;
 
   export type ArrayExpressionOperatorReturningArray =
-    Expression.ConcatArrays |
-    Expression.Filter |
-    Expression.Map |
-    Expression.ObjectToArray |
-    Expression.Range |
-    Expression.ReverseArray |
-    Expression.Slice |
-    Expression.Zip;
+    | Expression.ConcatArrays
+    | Expression.Filter
+    | Expression.Map
+    | Expression.ObjectToArray
+    | Expression.Range
+    | Expression.ReverseArray
+    | Expression.Slice
+    | Expression.Zip;
 
   export type ArrayExpressionOperatorReturningNumber =
-    Expression.IndexOfArray |
-    Expression.Size;
+    | Expression.IndexOfArray
+    | Expression.Size;
 
-  export type ArrayExpressionOperatorReturningObject =
-    Expression.ArrayToObject;
+  export type ArrayExpressionOperatorReturningObject = Expression.ArrayToObject;
 
   export type ArrayExpressionOperatorReturningBoolean =
-    Expression.In |
-    Expression.IsArray;
+    | Expression.In
+    | Expression.IsArray;
 
   export type BooleanExpressionOperator =
-    Expression.And |
-    Expression.Or |
-    Expression.Not;
+    | Expression.And
+    | Expression.Or
+    | Expression.Not;
 
   export type ComparisonExpressionOperator =
-    ComparisonExpressionOperatorReturningBoolean |
-    ComparisonExpressionOperatorReturningNumber;
+    | ComparisonExpressionOperatorReturningBoolean
+    | ComparisonExpressionOperatorReturningNumber;
 
   export type ComparisonExpressionOperatorReturningBoolean =
-    Expression.Eq |
-    Expression.Gt |
-    Expression.Gte |
-    Expression.Lt |
-    Expression.Lte |
-    Expression.Ne;
+    | Expression.Eq
+    | Expression.Gt
+    | Expression.Gte
+    | Expression.Lt
+    | Expression.Lte
+    | Expression.Ne;
 
-  export type ComparisonExpressionOperatorReturningNumber =
-    Expression.Cmp;
+  export type ComparisonExpressionOperatorReturningNumber = Expression.Cmp;
 
   export type ConditionalExpressionOperator =
-    Expression.Cond |
-    Expression.IfNull |
-    Expression.Switch;
+    | Expression.Cond
+    | Expression.IfNull
+    | Expression.Switch;
 
   export type StringExpressionOperator =
-    StringExpressionOperatorReturningArray |
-    StringExpressionOperatorReturningBoolean |
-    StringExpressionOperatorReturningNumber |
-    StringExpressionOperatorReturningObject |
-    StringExpressionOperatorReturningString;
+    | StringExpressionOperatorReturningArray
+    | StringExpressionOperatorReturningBoolean
+    | StringExpressionOperatorReturningNumber
+    | StringExpressionOperatorReturningObject
+    | StringExpressionOperatorReturningString;
 
   export type StringExpressionOperatorReturningArray =
-    Expression.RegexFindAll |
-    Expression.Split;
+    | Expression.RegexFindAll
+    | Expression.Split;
 
-  export type StringExpressionOperatorReturningBoolean =
-    Expression.RegexMatch;
+  export type StringExpressionOperatorReturningBoolean = Expression.RegexMatch;
 
   export type StringExpressionOperatorReturningNumber =
-    Expression.IndexOfBytes |
-    Expression.IndexOfCP |
-    Expression.Strcasecmp |
-    Expression.StrLenBytes |
-    Expression.StrLenCP;
+    | Expression.IndexOfBytes
+    | Expression.IndexOfCP
+    | Expression.Strcasecmp
+    | Expression.StrLenBytes
+    | Expression.StrLenCP;
 
-  export type StringExpressionOperatorReturningObject =
-    Expression.RegexFind;
+  export type StringExpressionOperatorReturningObject = Expression.RegexFind;
 
   export type StringExpressionOperatorReturningString =
-    Expression.Concat |
-    Expression.Ltrim |
-    Expression.Ltrim |
-    Expression.ReplaceOne |
-    Expression.ReplaceAll |
-    Expression.Substr |
-    Expression.SubstrBytes |
-    Expression.SubstrCP |
-    Expression.ToLower |
-    Expression.ToString |
-    Expression.ToUpper |
-    Expression.Trim;
+    | Expression.Concat
+    | Expression.Ltrim
+    | Expression.Ltrim
+    | Expression.ReplaceOne
+    | Expression.ReplaceAll
+    | Expression.Substr
+    | Expression.SubstrBytes
+    | Expression.SubstrCP
+    | Expression.ToLower
+    | Expression.ToString
+    | Expression.ToUpper
+    | Expression.Trim;
 
   export type ObjectExpressionOperator =
-    Expression.MergeObjects |
-    Expression.ObjectToArray |
-    Expression.SetField |
-    Expression.UnsetField;
+    | Expression.MergeObjects
+    | Expression.ObjectToArray
+    | Expression.SetField
+    | Expression.UnsetField;
 
-  export type ObjectExpressionOperatorReturningArray =
-    Expression.ObjectToArray;
+  export type ObjectExpressionOperatorReturningArray = Expression.ObjectToArray;
 
   export type ObjectExpressionOperatorReturningObject =
-    Expression.MergeObjects |
-    Expression.SetField |
-    Expression.UnsetField;
+    | Expression.MergeObjects
+    | Expression.SetField
+    | Expression.UnsetField;
 
-  export type VariableExpressionOperator =
-    Expression.Let;
+  export type VariableExpressionOperator = Expression.Let;
 
-  export type VariableExpressionOperatorReturningAny =
-    Expression.Let;
+  export type VariableExpressionOperatorReturningAny = Expression.Let;
 
   export type SetExpressionOperator =
-    Expression.AllElementsTrue |
-    Expression.AnyElementsTrue |
-    Expression.SetDifference |
-    Expression.SetEquals |
-    Expression.SetIntersection |
-    Expression.SetIsSubset |
-    Expression.SetUnion;
+    | Expression.AllElementsTrue
+    | Expression.AnyElementsTrue
+    | Expression.SetDifference
+    | Expression.SetEquals
+    | Expression.SetIntersection
+    | Expression.SetIsSubset
+    | Expression.SetUnion;
 
   export type SetExpressionOperatorReturningBoolean =
-    Expression.AllElementsTrue |
-    Expression.AnyElementsTrue |
-    Expression.SetEquals |
-    Expression.SetIsSubset;
+    | Expression.AllElementsTrue
+    | Expression.AnyElementsTrue
+    | Expression.SetEquals
+    | Expression.SetIsSubset;
 
   export type SetExpressionOperatorReturningArray =
-    Expression.SetDifference |
-    Expression.SetIntersection |
-    Expression.SetUnion;
+    | Expression.SetDifference
+    | Expression.SetIntersection
+    | Expression.SetUnion;
 
   /**
    * Trigonometry expressions perform trigonometric operations on numbers.
@@ -2733,204 +2797,305 @@ declare module 'mongoose' {
    * and radian measurements.
    */
   export type TrigonometryExpressionOperator =
-    Expression.Sin |
-    Expression.Cos |
-    Expression.Tan |
-    Expression.Asin |
-    Expression.Acos |
-    Expression.Atan |
-    Expression.Atan2 |
-    Expression.Asinh |
-    Expression.Acosh |
-    Expression.Atanh |
-    Expression.Sinh |
-    Expression.Cosh |
-    Expression.Tanh |
-    Expression.DegreesToRadians |
-    Expression.RadiansToDegrees;
-
-  export type TextExpressionOperator =
-    Expression.Meta;
+    | Expression.Sin
+    | Expression.Cos
+    | Expression.Tan
+    | Expression.Asin
+    | Expression.Acos
+    | Expression.Atan
+    | Expression.Atan2
+    | Expression.Asinh
+    | Expression.Acosh
+    | Expression.Atanh
+    | Expression.Sinh
+    | Expression.Cosh
+    | Expression.Tanh
+    | Expression.DegreesToRadians
+    | Expression.RadiansToDegrees;
+
+  export type TextExpressionOperator = Expression.Meta;
 
   export type WindowOperator =
-    Expression.AddToSet |
-    Expression.Avg |
-    Expression.Count |
-    Expression.CovariancePop |
-    Expression.CovarianceSamp |
-    Expression.DenseRank |
-    Expression.Derivative |
-    Expression.DocumentNumber |
-    Expression.ExpMovingAvg |
-    Expression.First |
-    Expression.Integral |
-    Expression.Last |
-    Expression.LinearFill |
-    Expression.Locf |
-    Expression.Max |
-    Expression.Min |
-    Expression.Push |
-    Expression.Rank |
-    Expression.Shift |
-    Expression.StdDevPop |
-    Expression.StdDevSamp |
-    Expression.Sum;
+    | Expression.AddToSet
+    | Expression.Avg
+    | Expression.Count
+    | Expression.CovariancePop
+    | Expression.CovarianceSamp
+    | Expression.DenseRank
+    | Expression.Derivative
+    | Expression.DocumentNumber
+    | Expression.ExpMovingAvg
+    | Expression.First
+    | Expression.Integral
+    | Expression.Last
+    | Expression.LinearFill
+    | Expression.Locf
+    | Expression.Max
+    | Expression.Min
+    | Expression.Push
+    | Expression.Rank
+    | Expression.Shift
+    | Expression.StdDevPop
+    | Expression.StdDevSamp
+    | Expression.Sum;
 
   export type WindowOperatorReturningAny =
-    Expression.First |
-    Expression.Last |
-    Expression.Shift;
+    | Expression.First
+    | Expression.Last
+    | Expression.Shift;
 
   export type WindowOperatorReturningArray =
-    Expression.AddToSet |
-    Expression.Push;
+    | Expression.AddToSet
+    | Expression.Push;
 
   export type WindowOperatorReturningNumber =
-    Expression.Avg |
-    Expression.Count |
-    Expression.CovariancePop |
-    Expression.CovarianceSamp |
-    Expression.DenseRank |
-    Expression.DocumentNumber |
-    Expression.ExpMovingAvg |
-    Expression.Integral |
-    Expression.Max |
-    Expression.Min |
-    Expression.StdDevPop |
-    Expression.StdDevSamp |
-    Expression.Sum;
+    | Expression.Avg
+    | Expression.Count
+    | Expression.CovariancePop
+    | Expression.CovarianceSamp
+    | Expression.DenseRank
+    | Expression.DocumentNumber
+    | Expression.ExpMovingAvg
+    | Expression.Integral
+    | Expression.Max
+    | Expression.Min
+    | Expression.StdDevPop
+    | Expression.StdDevSamp
+    | Expression.Sum;
 
   export type TypeExpressionOperator =
-    Expression.Convert |
-    Expression.IsNumber |
-    Expression.ToBool |
-    Expression.ToDate |
-    Expression.ToDecimal |
-    Expression.ToDouble |
-    Expression.ToInt |
-    Expression.ToLong |
-    Expression.ToObjectId |
-    Expression.ToString |
-    Expression.Type;
+    | Expression.Convert
+    | Expression.IsNumber
+    | Expression.ToBool
+    | Expression.ToDate
+    | Expression.ToDecimal
+    | Expression.ToDouble
+    | Expression.ToInt
+    | Expression.ToLong
+    | Expression.ToObjectId
+    | Expression.ToString
+    | Expression.Type;
 
   export type TypeExpressionOperatorReturningNumber =
-    Expression.Convert<'double' | 1 | 'int' | 16 | 'long' | 18 | 'decimal' | 19> |
-    Expression.ToDecimal |
-    Expression.ToDouble |
-    Expression.ToInt |
-    Expression.ToLong;
+    | Expression.Convert<
+        'double' | 1 | 'int' | 16 | 'long' | 18 | 'decimal' | 19
+      >
+    | Expression.ToDecimal
+    | Expression.ToDouble
+    | Expression.ToInt
+    | Expression.ToLong;
 
   export type TypeExpressionOperatorReturningBoolean =
-    Expression.Convert<'bool' | 8> |
-    Expression.IsNumber |
-    Expression.ToBool;
-
+    | Expression.Convert<'bool' | 8>
+    | Expression.IsNumber
+    | Expression.ToBool;
 
   export type TypeExpressionOperatorReturningString =
-    Expression.Convert<'string' | 2> |
-    Expression.ToString |
-    Expression.Type;
+    | Expression.Convert<'string' | 2>
+    | Expression.ToString
+    | Expression.Type;
 
   export type TypeExpressionOperatorReturningObjectId =
-    Expression.Convert<'objectId' | 7> |
-    Expression.ToObjectId;
+    | Expression.Convert<'objectId' | 7>
+    | Expression.ToObjectId;
 
   export type TypeExpressionOperatorReturningDate =
-    Expression.Convert<'date' | 9> |
-    Expression.ToDate;
+    | Expression.Convert<'date' | 9>
+    | Expression.ToDate;
 
-  export type DataSizeOperator =
-    Expression.BinarySize |
-    Expression.BsonSize;
+  export type DataSizeOperator = Expression.BinarySize | Expression.BsonSize;
 
   export type DataSizeOperatorReturningNumber =
-    Expression.BinarySize |
-    Expression.BsonSize;
+    | Expression.BinarySize
+    | Expression.BsonSize;
 
   export type CustomAggregationExpressionOperator =
-    Expression.Accumulator |
-    Expression.Function;
+    | Expression.Accumulator
+    | Expression.Function;
 
   export type CustomAggregationExpressionOperatorReturningAny =
     Expression.Function;
 
   export type AccumulatorOperator =
-    Expression.Accumulator |
-    Expression.AddToSet |
-    Expression.Avg |
-    Expression.Count |
-    Expression.First |
-    Expression.Last |
-    Expression.Max |
-    Expression.MergeObjects |
-    Expression.Min |
-    Expression.Push |
-    Expression.StdDevPop |
-    Expression.StdDevSamp |
-    Expression.Sum |
-    Expression.Top |
-    Expression.TopN;
-
-  export type tzExpression = UTCOffset | StringExpressionOperatorReturningBoolean | string;
-
-  type hh = '-00' | '-01' | '-02' | '-03' | '-04' | '-05' | '-06' | '-07' | '-08' | '-09' | '-10' | '-11' | '-12' |
-  '+00' | '+01' | '+02' | '+03' | '+04' | '+05' | '+06' | '+07' | '+08' | '+09' | '+10' | '+11' | '+12' | '+13' | '+14';
+    | Expression.Accumulator
+    | Expression.AddToSet
+    | Expression.Avg
+    | Expression.Count
+    | Expression.First
+    | Expression.Last
+    | Expression.Max
+    | Expression.MergeObjects
+    | Expression.Min
+    | Expression.Push
+    | Expression.StdDevPop
+    | Expression.StdDevSamp
+    | Expression.Sum
+    | Expression.Top
+    | Expression.TopN;
+
+  export type tzExpression =
+    | UTCOffset
+    | StringExpressionOperatorReturningBoolean
+    | string;
+
+  type hh =
+    | '-00'
+    | '-01'
+    | '-02'
+    | '-03'
+    | '-04'
+    | '-05'
+    | '-06'
+    | '-07'
+    | '-08'
+    | '-09'
+    | '-10'
+    | '-11'
+    | '-12'
+    | '+00'
+    | '+01'
+    | '+02'
+    | '+03'
+    | '+04'
+    | '+05'
+    | '+06'
+    | '+07'
+    | '+08'
+    | '+09'
+    | '+10'
+    | '+11'
+    | '+12'
+    | '+13'
+    | '+14';
   type mm = '00' | '30' | '45';
 
   type UTCOffset = `${hh}` | `${hh}${mm}` | `${hh}:${mm}`;
 
   type RegexOptions =
-    'i' | 'm' | 's' | 'x' |
-    'is' | 'im' | 'ix' | 'si' | 'sm' | 'sx' | 'mi' | 'ms' | 'mx' | 'xi' | 'xs' | 'xm' |
-    'ism' | 'isx' | 'ims' | 'imx' | 'ixs' | 'ixm' | 'sim' | 'six' | 'smi' | 'smx' | 'sxi' | 'sxm' | 'mis' | 'mix' | 'msi' | 'msx' | 'mxi' | 'mxs' | 'xis' | 'xim' | 'xsi' | 'xsm' | 'xmi' | 'xms' |
-    'ismx' | 'isxm' | 'imsx' | 'imxs' | 'ixsm' | 'ixms' | 'simx' | 'sixm' | 'smix' | 'smxi' | 'sxim' | 'sxmi' | 'misx' | 'mixs' | 'msix' | 'msxi' | 'mxis' | 'mxsi' | 'xism' | 'xims' | 'xsim' | 'xsmi' | 'xmis' | 'xmsi';
+    | 'i'
+    | 'm'
+    | 's'
+    | 'x'
+    | 'is'
+    | 'im'
+    | 'ix'
+    | 'si'
+    | 'sm'
+    | 'sx'
+    | 'mi'
+    | 'ms'
+    | 'mx'
+    | 'xi'
+    | 'xs'
+    | 'xm'
+    | 'ism'
+    | 'isx'
+    | 'ims'
+    | 'imx'
+    | 'ixs'
+    | 'ixm'
+    | 'sim'
+    | 'six'
+    | 'smi'
+    | 'smx'
+    | 'sxi'
+    | 'sxm'
+    | 'mis'
+    | 'mix'
+    | 'msi'
+    | 'msx'
+    | 'mxi'
+    | 'mxs'
+    | 'xis'
+    | 'xim'
+    | 'xsi'
+    | 'xsm'
+    | 'xmi'
+    | 'xms'
+    | 'ismx'
+    | 'isxm'
+    | 'imsx'
+    | 'imxs'
+    | 'ixsm'
+    | 'ixms'
+    | 'simx'
+    | 'sixm'
+    | 'smix'
+    | 'smxi'
+    | 'sxim'
+    | 'sxmi'
+    | 'misx'
+    | 'mixs'
+    | 'msix'
+    | 'msxi'
+    | 'mxis'
+    | 'mxsi'
+    | 'xism'
+    | 'xims'
+    | 'xsim'
+    | 'xsmi'
+    | 'xmis'
+    | 'xmsi';
 
   type StartOfWeek =
-    'monday' | 'mon' |
-    'tuesday' | 'tue' |
-    'wednesday' | 'wed' |
-    'thursday' | 'thu' |
-    'friday' | 'fri' |
-    'saturday' | 'sat' |
-    'sunday' | 'sun';
-
-  type DateUnit = 'year' | 'quarter' | 'week' | 'month' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';
+    | 'monday'
+    | 'mon'
+    | 'tuesday'
+    | 'tue'
+    | 'wednesday'
+    | 'wed'
+    | 'thursday'
+    | 'thu'
+    | 'friday'
+    | 'fri'
+    | 'saturday'
+    | 'sat'
+    | 'sunday'
+    | 'sun';
+
+  type DateUnit =
+    | 'year'
+    | 'quarter'
+    | 'week'
+    | 'month'
+    | 'day'
+    | 'hour'
+    | 'minute'
+    | 'second'
+    | 'millisecond';
 
   type FormatString = string;
 
   export type DateExpressionOperator =
-    DateExpressionOperatorReturningDate |
-    DateExpressionOperatorReturningNumber |
-    DateExpressionOperatorReturningString |
-    DateExpressionOperatorReturningObject;
+    | DateExpressionOperatorReturningDate
+    | DateExpressionOperatorReturningNumber
+    | DateExpressionOperatorReturningString
+    | DateExpressionOperatorReturningObject;
 
-  export type DateExpressionOperatorReturningObject =
-    Expression.DateToParts;
+  export type DateExpressionOperatorReturningObject = Expression.DateToParts;
 
   export type DateExpressionOperatorReturningNumber =
-    Expression.DateDiff |
-    Expression.DayOfMonth |
-    Expression.DayOfWeek |
-    Expression.DayOfYear |
-    Expression.IsoDayOfWeek |
-    Expression.IsoWeek |
-    Expression.IsoWeekYear |
-    Expression.Millisecond |
-    Expression.Second |
-    Expression.Minute |
-    Expression.Hour |
-    Expression.Month |
-    Expression.Year;
+    | Expression.DateDiff
+    | Expression.DayOfMonth
+    | Expression.DayOfWeek
+    | Expression.DayOfYear
+    | Expression.IsoDayOfWeek
+    | Expression.IsoWeek
+    | Expression.IsoWeekYear
+    | Expression.Millisecond
+    | Expression.Second
+    | Expression.Minute
+    | Expression.Hour
+    | Expression.Month
+    | Expression.Year;
 
   export type DateExpressionOperatorReturningDate =
-    Expression.DateAdd |
-    Expression.DateFromParts |
-    Expression.DateFromString |
-    Expression.DateSubtract |
-    Expression.DateTrunc |
-    Expression.ToDate;
-
-  export type DateExpressionOperatorReturningString =
-    Expression.DateToString;
-
+    | Expression.DateAdd
+    | Expression.DateFromParts
+    | Expression.DateFromString
+    | Expression.DateSubtract
+    | Expression.DateTrunc
+    | Expression.ToDate;
+
+  export type DateExpressionOperatorReturningString = Expression.DateToString;
 }
diff --git a/types/helpers.d.ts b/types/helpers.d.ts
index 91e2ea27577321fd4c9d0ce0ca549c26bca7e8d0..11b77f9486072c1a89b3dcd84c0c8566c20e97b2 100644
--- a/types/helpers.d.ts
+++ b/types/helpers.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   /**
diff --git a/types/index.d.ts b/types/index.d.ts
index 668f67e55d1b4b2abe1f2c71d3783b85b8164b2f..b3729821ec0cf2af3b0039adf7f8fee099cd2c97 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -25,9 +25,9 @@
 /// <reference path="./virtuals.d.ts" />
 /// <reference path="./augmentations.d.ts" />
 
-declare class NativeDate extends globalThis.Date { }
+declare class NativeDate extends globalThis.Date {}
 
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import Kareem = require('kareem');
   import events = require('events');
   import mongodb = require('mongodb');
@@ -47,7 +47,7 @@ declare module 'mongoose' {
    * Can be extended to explicitly type specific models.
    */
   export interface Models {
-    [modelName: string]: Model<any>
+    [modelName: string]: Model<any>;
   }
 
   /** An array containing all models associated with this Mongoose instance. */
@@ -67,41 +67,50 @@ declare module 'mongoose' {
   export function sanitizeFilter<T>(filter: FilterQuery<T>): FilterQuery<T>;
 
   /** Gets mongoose options */
-  export function get<K extends keyof MongooseOptions>(key: K): MongooseOptions[K];
+  export function get<K extends keyof MongooseOptions>(
+    key: K,
+  ): MongooseOptions[K];
 
   export function omitUndefined<T extends Record<string, any>>(val: T): T;
 
   /* ! ignore */
   export type CompileModelOptions = {
-    overwriteModels?: boolean,
-    connection?: Connection
+    overwriteModels?: boolean;
+    connection?: Connection;
   };
 
   export function model<TSchema extends Schema = any>(
     name: string,
     schema?: TSchema,
     collection?: string,
-    options?: CompileModelOptions
+    options?: CompileModelOptions,
   ): Model<
-  InferSchemaType<TSchema>,
-  ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
-  ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
-  ObtainSchemaGeneric<TSchema, 'TVirtuals'>,
-  HydratedDocument<
-  InferSchemaType<TSchema>,
-  ObtainSchemaGeneric<TSchema, 'TVirtuals'> & ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
-  ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
-  >,
-  TSchema
-  > & ObtainSchemaGeneric<TSchema, 'TStaticMethods'>;
-
-  export function model<T>(name: string, schema?: Schema<T, any, any> | Schema<T & Document, any, any>, collection?: string, options?: CompileModelOptions): Model<T>;
+    InferSchemaType<TSchema>,
+    ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
+    ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
+    ObtainSchemaGeneric<TSchema, 'TVirtuals'>,
+    HydratedDocument<
+      InferSchemaType<TSchema>,
+      ObtainSchemaGeneric<TSchema, 'TVirtuals'> &
+        ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
+      ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
+    >,
+    TSchema
+  > &
+    ObtainSchemaGeneric<TSchema, 'TStaticMethods'>;
+
+  export function model<T>(
+    name: string,
+    schema?: Schema<T, any, any> | Schema<T & Document, any, any>,
+    collection?: string,
+    options?: CompileModelOptions,
+  ): Model<T>;
 
   export function model<T, U, TQueryHelpers = {}>(
     name: string,
     schema?: Schema<T, any, any, TQueryHelpers, any, any, any>,
     collection?: string,
-    options?: CompileModelOptions
+    options?: CompileModelOptions,
   ): U;
 
   /** Returns an array of model names created on this instance of Mongoose. */
@@ -117,21 +126,31 @@ declare module 'mongoose' {
   export { mongodb as mongo };
 
   /** Declares a global plugin executed on all Schemas. */
-  export function plugin(fn: (schema: Schema, opts?: any) => void, opts?: any): Mongoose;
+  export function plugin(
+    fn: (schema: Schema, opts?: any) => void,
+    opts?: any,
+  ): Mongoose;
 
   /** Getter/setter around function for pluralizing collection names. */
-  export function pluralize(fn?: ((str: string) => string) | null): ((str: string) => string) | null;
+  export function pluralize(
+    fn?: ((str: string) => string) | null,
+  ): ((str: string) => string) | null;
 
   /** Sets mongoose options */
-  export function set<K extends keyof MongooseOptions>(key: K, value: MongooseOptions[K]): Mongoose;
-  export function set(options: { [K in keyof MongooseOptions]: MongooseOptions[K] }): Mongoose;
+  export function set<K extends keyof MongooseOptions>(
+    key: K,
+    value: MongooseOptions[K],
+  ): Mongoose;
+  export function set(options: {
+    [K in keyof MongooseOptions]: MongooseOptions[K];
+  }): Mongoose;
 
   /** The Mongoose version */
   export const version: string;
 
   export type AnyKeys<T> = { [P in keyof T]?: T[P] | any };
   export interface AnyObject {
-    [k: string]: any
+    [k: string]: any;
   }
 
   export type Require_id<T> = T extends { _id?: infer U }
@@ -146,64 +165,64 @@ declare module 'mongoose' {
   export type HydratedDocument<
     DocType,
     TOverrides = {},
-    TQueryHelpers = {}
+    TQueryHelpers = {},
   > = IfAny<
     DocType,
     any,
-    TOverrides extends Record<string, never> ?
-      Document<unknown, TQueryHelpers, DocType> & Default__v<Require_id<DocType>> :
-      IfAny<
-        TOverrides,
-        Document<unknown, TQueryHelpers, DocType> & Default__v<Require_id<DocType>>,
-        Document<unknown, TQueryHelpers, DocType> & MergeType<
-          Default__v<Require_id<DocType>>,
-          TOverrides
+    TOverrides extends Record<string, never>
+      ? Document<unknown, TQueryHelpers, DocType> &
+          Default__v<Require_id<DocType>>
+      : IfAny<
+          TOverrides,
+          Document<unknown, TQueryHelpers, DocType> &
+            Default__v<Require_id<DocType>>,
+          Document<unknown, TQueryHelpers, DocType> &
+            MergeType<Default__v<Require_id<DocType>>, TOverrides>
         >
-      >
   >;
-  export type HydratedSingleSubdocument<
+  export type HydratedSingleSubdocument<DocType, TOverrides = {}> = IfAny<
     DocType,
-    TOverrides = {}
-  > = IfAny<
-  DocType,
-  any,
-  TOverrides extends Record<string, never> ?
-    Types.Subdocument<unknown, Record<string, never>, DocType> & Require_id<DocType> :
-    IfAny<
-      TOverrides,
-      Types.Subdocument<unknown, Record<string, never>, DocType> & Require_id<DocType>,
-      Types.Subdocument<unknown, Record<string, never>, DocType> & MergeType<
-        Require_id<DocType>,
-        TOverrides
-      >
-    >
+    any,
+    TOverrides extends Record<string, never>
+      ? Types.Subdocument<unknown, Record<string, never>, DocType> &
+          Require_id<DocType>
+      : IfAny<
+          TOverrides,
+          Types.Subdocument<unknown, Record<string, never>, DocType> &
+            Require_id<DocType>,
+          Types.Subdocument<unknown, Record<string, never>, DocType> &
+            MergeType<Require_id<DocType>, TOverrides>
+        >
   >;
   export type HydratedArraySubdocument<DocType, TOverrides = {}> = IfAny<
     DocType,
     any,
-    TOverrides extends Record<string, never> ?
-      Types.ArraySubdocument<unknown, Record<string, never>, DocType> & Require_id<DocType> :
-      IfAny<
-        TOverrides,
-        Types.ArraySubdocument<unknown, Record<string, never>, DocType> & Require_id<DocType>,
-        Types.ArraySubdocument<unknown, Record<string, never>, DocType> & MergeType<
-          Require_id<DocType>,
-          TOverrides
+    TOverrides extends Record<string, never>
+      ? Types.ArraySubdocument<unknown, Record<string, never>, DocType> &
+          Require_id<DocType>
+      : IfAny<
+          TOverrides,
+          Types.ArraySubdocument<unknown, Record<string, never>, DocType> &
+            Require_id<DocType>,
+          Types.ArraySubdocument<unknown, Record<string, never>, DocType> &
+            MergeType<Require_id<DocType>, TOverrides>
         >
-      >
-    >;
-
-  export type HydratedDocumentFromSchema<TSchema extends Schema> = HydratedDocument<
-  InferSchemaType<TSchema>,
-  ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
-  ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
   >;
 
+  export type HydratedDocumentFromSchema<TSchema extends Schema> =
+    HydratedDocument<
+      InferSchemaType<TSchema>,
+      ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
+      ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
+    >;
+
   export interface TagSet {
     [k: string]: string;
   }
 
-  export interface ToObjectOptions<THydratedDocumentType = HydratedDocument<unknown>> {
+  export interface ToObjectOptions<
+    THydratedDocumentType = HydratedDocument<unknown>,
+  > {
     /** apply all getters (path and virtual getters) */
     getters?: boolean;
     /** apply virtual getters (can override getters option) */
@@ -213,11 +232,13 @@ declare module 'mongoose' {
     /** remove empty objects (defaults to true) */
     minimize?: boolean;
     /** if set, mongoose will call this function to allow you to transform the returned object */
-    transform?: boolean | ((
-      doc: THydratedDocumentType,
-      ret: Record<string, any>,
-      options: ToObjectOptions<THydratedDocumentType>
-    ) => any);
+    transform?:
+      | boolean
+      | ((
+          doc: THydratedDocumentType,
+          ret: Record<string, any>,
+          options: ToObjectOptions<THydratedDocumentType>,
+        ) => any);
     /** if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths. */
     depopulate?: boolean;
     /** if false, exclude the version key (`__v` by default) from the output */
@@ -230,19 +251,64 @@ declare module 'mongoose' {
     useProjection?: boolean;
   }
 
-  export type DiscriminatorModel<M, T> = T extends Model<infer T, infer TQueryHelpers, infer TInstanceMethods, infer TVirtuals>
-    ?
-    M extends Model<infer M, infer MQueryHelpers, infer MInstanceMethods, infer MVirtuals>
-      ? Model<Omit<M, keyof T> & T, MQueryHelpers | TQueryHelpers, MInstanceMethods | TInstanceMethods, MVirtuals | TVirtuals>
-      : M
-    : M;
-
-  export type DiscriminatorSchema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods, DisSchema> =
-    DisSchema extends Schema<infer DisSchemaEDocType, infer DisSchemaM, infer DisSchemaInstanceMethods, infer DisSchemaQueryhelpers, infer DisSchemaVirtuals, infer DisSchemaStatics>
-      ? Schema<MergeType<DocType, DisSchemaEDocType>, DiscriminatorModel<DisSchemaM, M>, DisSchemaInstanceMethods | TInstanceMethods, DisSchemaQueryhelpers | TQueryHelpers, DisSchemaVirtuals | TVirtuals, DisSchemaStatics & TStaticMethods>
-      : Schema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods>;
-
-  type QueryResultType<T> = T extends Query<infer ResultType, any> ? ResultType : never;
+  export type DiscriminatorModel<M, T> =
+    T extends Model<
+      infer T,
+      infer TQueryHelpers,
+      infer TInstanceMethods,
+      infer TVirtuals
+    >
+      ? M extends Model<
+          infer M,
+          infer MQueryHelpers,
+          infer MInstanceMethods,
+          infer MVirtuals
+        >
+        ? Model<
+            Omit<M, keyof T> & T,
+            MQueryHelpers | TQueryHelpers,
+            MInstanceMethods | TInstanceMethods,
+            MVirtuals | TVirtuals
+          >
+        : M
+      : M;
+
+  export type DiscriminatorSchema<
+    DocType,
+    M,
+    TInstanceMethods,
+    TQueryHelpers,
+    TVirtuals,
+    TStaticMethods,
+    DisSchema,
+  > =
+    DisSchema extends Schema<
+      infer DisSchemaEDocType,
+      infer DisSchemaM,
+      infer DisSchemaInstanceMethods,
+      infer DisSchemaQueryhelpers,
+      infer DisSchemaVirtuals,
+      infer DisSchemaStatics
+    >
+      ? Schema<
+          MergeType<DocType, DisSchemaEDocType>,
+          DiscriminatorModel<DisSchemaM, M>,
+          DisSchemaInstanceMethods | TInstanceMethods,
+          DisSchemaQueryhelpers | TQueryHelpers,
+          DisSchemaVirtuals | TVirtuals,
+          DisSchemaStatics & TStaticMethods
+        >
+      : Schema<
+          DocType,
+          M,
+          TInstanceMethods,
+          TQueryHelpers,
+          TVirtuals,
+          TStaticMethods
+        >;
+
+  type QueryResultType<T> =
+    T extends Query<infer ResultType, any> ? ResultType : never;
 
   type PluginFunction<
     DocType,
@@ -250,7 +316,18 @@ declare module 'mongoose' {
     TInstanceMethods,
     TQueryHelpers,
     TVirtuals,
-    TStaticMethods> = (schema: Schema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods>, opts?: any) => void;
+    TStaticMethods,
+  > = (
+    schema: Schema<
+      DocType,
+      M,
+      TInstanceMethods,
+      TQueryHelpers,
+      TVirtuals,
+      TStaticMethods
+    >,
+    opts?: any,
+  ) => void;
 
   export class Schema<
     RawDocType = any,
@@ -261,22 +338,45 @@ declare module 'mongoose' {
     TStaticMethods = {},
     TSchemaOptions = DefaultSchemaOptions,
     DocType extends ApplySchemaOptions<
-      ObtainDocumentType<DocType, RawDocType, ResolveSchemaOptions<TSchemaOptions>>,
+      ObtainDocumentType<
+        DocType,
+        RawDocType,
+        ResolveSchemaOptions<TSchemaOptions>
+      >,
       ResolveSchemaOptions<TSchemaOptions>
     > = ApplySchemaOptions<
       ObtainDocumentType<any, RawDocType, ResolveSchemaOptions<TSchemaOptions>>,
       ResolveSchemaOptions<TSchemaOptions>
     >,
-    THydratedDocumentType = HydratedDocument<FlatRecord<DocType>, TVirtuals & TInstanceMethods>
-  >
-    extends events.EventEmitter {
+    THydratedDocumentType = HydratedDocument<
+      FlatRecord<DocType>,
+      TVirtuals & TInstanceMethods
+    >,
+  > extends events.EventEmitter {
     /**
      * Create a new schema
      */
-    constructor(definition?: SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType> | DocType, options?: SchemaOptions<FlatRecord<DocType>, TInstanceMethods, TQueryHelpers, TStaticMethods, TVirtuals, THydratedDocumentType> | ResolveSchemaOptions<TSchemaOptions>);
+    constructor(
+      definition?:
+        | SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType>
+        | DocType,
+      options?:
+        | SchemaOptions<
+            FlatRecord<DocType>,
+            TInstanceMethods,
+            TQueryHelpers,
+            TStaticMethods,
+            TVirtuals,
+            THydratedDocumentType
+          >
+        | ResolveSchemaOptions<TSchemaOptions>,
+    );
 
     /** Adds key path / schema type pairs to this schema. */
-    add(obj: SchemaDefinition<SchemaDefinitionType<RawDocType>> | Schema, prefix?: string): this;
+    add(
+      obj: SchemaDefinition<SchemaDefinitionType<RawDocType>> | Schema,
+      prefix?: string,
+    ): this;
 
     /**
      * Add an alias for `path`. This means getting or setting the `alias`
@@ -289,7 +389,7 @@ declare module 'mongoose' {
      * and their corresponding compiled models. Each element of the array is
      * an object with 2 properties: `schema` and `model`.
      */
-    childSchemas: { schema: Schema, model: any }[];
+    childSchemas: { schema: Schema; model: any }[];
 
     /** Removes all indexes on this schema */
     clearIndexes(): this;
@@ -297,7 +397,10 @@ declare module 'mongoose' {
     /** Returns a copy of this schema */
     clone<T = this>(): T;
 
-    discriminator<DisSchema = Schema>(name: string | number, schema: DisSchema): this;
+    discriminator<DisSchema = Schema>(
+      name: string | number,
+      schema: DisSchema,
+    ): this;
 
     /** Returns a new schema that has the picked `paths` from this schema. */
     pick<T = this>(paths: string[], options?: SchemaOptions): T;
@@ -337,11 +440,16 @@ declare module 'mongoose' {
     loadClass(model: Function, onlyVirtuals?: boolean): this;
 
     /** Adds an instance method to documents constructed from Models compiled from this schema. */
-    method<Context = THydratedDocumentType>(name: string, fn: (this: Context, ...args: any[]) => any, opts?: any): this;
+    method<Context = THydratedDocumentType>(
+      name: string,
+      fn: (this: Context, ...args: any[]) => any,
+      opts?: any,
+    ): this;
     method(obj: Partial<TInstanceMethods>): this;
 
     /** Object of currently defined methods on this schema. */
-    methods: AddThisParameter<TInstanceMethods, THydratedDocumentType> & AnyObject;
+    methods: AddThisParameter<TInstanceMethods, THydratedDocumentType> &
+      AnyObject;
 
     /** The original object passed to the schema constructor */
     obj: SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType>;
@@ -350,8 +458,12 @@ declare module 'mongoose' {
     omit<T = this>(paths: string[], options?: SchemaOptions): T;
 
     /** Gets/sets schema paths. */
-    path<ResultType extends SchemaType = SchemaType<any, THydratedDocumentType>>(path: string): ResultType;
-    path<pathGeneric extends keyof RawDocType>(path: pathGeneric): SchemaType<RawDocType[pathGeneric]>;
+    path<
+      ResultType extends SchemaType = SchemaType<any, THydratedDocumentType>,
+    >(path: string): ResultType;
+    path<pathGeneric extends keyof RawDocType>(
+      path: pathGeneric,
+    ): SchemaType<RawDocType[pathGeneric]>;
     path(path: string, constructor: any): this;
 
     /** Lists all paths and their type in the schema. */
@@ -363,94 +475,368 @@ declare module 'mongoose' {
     pathType(path: string): string;
 
     /** Registers a plugin for this schema. */
-    plugin<PFunc extends PluginFunction<DocType, TModelType, any, any, any, any>, POptions extends Parameters<PFunc>[1] = Parameters<PFunc>[1]>(fn: PFunc, opts?: POptions): this;
+    plugin<
+      PFunc extends PluginFunction<DocType, TModelType, any, any, any, any>,
+      POptions extends Parameters<PFunc>[1] = Parameters<PFunc>[1],
+    >(fn: PFunc, opts?: POptions): this;
 
     /** Defines a post hook for the model. */
 
     // PostMiddlewareFunction
     // with errorHandler set to true
-    post<T = Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;
-    post<T = THydratedDocumentType>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;
-    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T, Array<any>>): this;
-    post<T = TModelType>(method: 'insertMany' | RegExp, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;
+    post<T = Query<any, any>>(
+      method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | RegExp,
+      options: SchemaPostOptions & { errorHandler: true },
+      fn: ErrorHandlingMiddlewareWithOption<T>,
+    ): this;
+    post<T = THydratedDocumentType>(
+      method:
+        | MongooseDocumentMiddleware
+        | MongooseDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { errorHandler: true },
+      fn: ErrorHandlingMiddlewareWithOption<T>,
+    ): this;
+    post<T extends Aggregate<any>>(
+      method: 'aggregate' | RegExp,
+      options: SchemaPostOptions & { errorHandler: true },
+      fn: ErrorHandlingMiddlewareWithOption<T, Array<any>>,
+    ): this;
+    post<T = TModelType>(
+      method: 'insertMany' | RegExp,
+      options: SchemaPostOptions & { errorHandler: true },
+      fn: ErrorHandlingMiddlewareWithOption<T>,
+    ): this;
 
     // this = never since it never happens
-    post<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: false }, fn: PostMiddlewareFunction<never, never>): this;
-    post<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions & { document: boolean, query: false }, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
-    post<T = never>(method: MongooseDistinctDocumentMiddleware | MongooseDistinctDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: true }, fn: PostMiddlewareFunction<T, T>): this;
+    post<T = never>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: false; query: false },
+      fn: PostMiddlewareFunction<never, never>,
+    ): this;
+    post<T = never>(
+      method:
+        | MongooseDistinctQueryMiddleware
+        | MongooseDistinctQueryMiddleware[],
+      options: SchemaPostOptions & { document: boolean; query: false },
+      fn: PostMiddlewareFunction<T, QueryResultType<T>>,
+    ): this;
+    post<T = never>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: false; query: true },
+      fn: PostMiddlewareFunction<T, T>,
+    ): this;
     // this = Document
-    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: PostMiddlewareFunction<T, T>): this;
-    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions & SchemaPostOptions, fn: PostMiddlewareFunction<T, T>): this;
-    post<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: false }, fn: PostMiddlewareFunction<T, T>): this;
+    post<T = THydratedDocumentType>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[],
+      fn: PostMiddlewareFunction<T, T>,
+    ): this;
+    post<T = THydratedDocumentType>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[],
+      options: SchemaPostOptions & SchemaPostOptions,
+      fn: PostMiddlewareFunction<T, T>,
+    ): this;
+    post<T = THydratedDocumentType>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: true; query: false },
+      fn: PostMiddlewareFunction<T, T>,
+    ): this;
     // this = Query
-    post<T = Query<any, any>>(method: MongooseRawResultQueryMiddleware|MongooseRawResultQueryMiddleware[], fn: PostMiddlewareFunction<T, null | QueryResultType<T> | ModifyResult<QueryResultType<T>>>): this;
-    post<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
-    post<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
-    post<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: true }, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
+    post<T = Query<any, any>>(
+      method:
+        | MongooseRawResultQueryMiddleware
+        | MongooseRawResultQueryMiddleware[],
+      fn: PostMiddlewareFunction<
+        T,
+        null | QueryResultType<T> | ModifyResult<QueryResultType<T>>
+      >,
+    ): this;
+    post<T = Query<any, any>>(
+      method: MongooseDefaultQueryMiddleware | MongooseDefaultQueryMiddleware[],
+      fn: PostMiddlewareFunction<T, QueryResultType<T>>,
+    ): this;
+    post<T = Query<any, any>>(
+      method:
+        | MongooseDistinctQueryMiddleware
+        | MongooseDistinctQueryMiddleware[],
+      options: SchemaPostOptions,
+      fn: PostMiddlewareFunction<T, QueryResultType<T>>,
+    ): this;
+    post<T = Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: false; query: true },
+      fn: PostMiddlewareFunction<T, QueryResultType<T>>,
+    ): this;
     // this = Union of Document and Query, could be called with any of them
-    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: true }, fn: PostMiddlewareFunction<T, T|QueryResultType<T>>): this;
-    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, fn: PostMiddlewareFunction<T, T|QueryResultType<T>>): this;
+    post<T = THydratedDocumentType | Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: true; query: true },
+      fn: PostMiddlewareFunction<T, T | QueryResultType<T>>,
+    ): this;
+    post<T = THydratedDocumentType | Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      fn: PostMiddlewareFunction<T, T | QueryResultType<T>>,
+    ): this;
 
     // ErrorHandlingMiddlewareFunction
     // this = never since it never happens
-    post<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions & { document: boolean, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = never>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions & { document: false, query: boolean }, fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
+    post<T = never>(
+      method:
+        | MongooseDistinctQueryMiddleware
+        | MongooseDistinctQueryMiddleware[],
+      options: SchemaPostOptions & { document: boolean; query: false },
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = never>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[],
+      options: SchemaPostOptions & { document: false; query: boolean },
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = never>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: false; query: false },
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
     // this = Document
-    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
+    post<T = THydratedDocumentType>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[],
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = THydratedDocumentType>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[],
+      options: SchemaPostOptions,
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = THydratedDocumentType>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: true; query: false },
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
     // this = Query
-    post<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: false, query: true }, fn: ErrorHandlingMiddlewareFunction<T>): this;
+    post<T = Query<any, any>>(
+      method: MongooseDefaultQueryMiddleware | MongooseDefaultQueryMiddleware[],
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = Query<any, any>>(
+      method:
+        | MongooseDistinctQueryMiddleware
+        | MongooseDistinctQueryMiddleware[],
+      options: SchemaPostOptions,
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: false; query: true },
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
     // this = Union of Document and Query, could be called with any of them
-    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPostOptions & { document: true, query: true }, fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, fn: ErrorHandlingMiddlewareFunction<T>): this;
+    post<T = THydratedDocumentType | Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPostOptions & { document: true; query: true },
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = THydratedDocumentType | Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
 
     // method aggregate and insertMany with PostMiddlewareFunction
-    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: PostMiddlewareFunction<T, Array<AggregateExtract<T>>>): this;
-    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T, Array<AggregateExtract<T>>>): this;
-    post<T = TModelType>(method: 'insertMany' | RegExp, fn: PostMiddlewareFunction<T, T>): this;
-    post<T = TModelType>(method: 'insertMany' | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T, T>): this;
+    post<T extends Aggregate<any>>(
+      method: 'aggregate' | RegExp,
+      fn: PostMiddlewareFunction<T, Array<AggregateExtract<T>>>,
+    ): this;
+    post<T extends Aggregate<any>>(
+      method: 'aggregate' | RegExp,
+      options: SchemaPostOptions,
+      fn: PostMiddlewareFunction<T, Array<AggregateExtract<T>>>,
+    ): this;
+    post<T = TModelType>(
+      method: 'insertMany' | RegExp,
+      fn: PostMiddlewareFunction<T, T>,
+    ): this;
+    post<T = TModelType>(
+      method: 'insertMany' | RegExp,
+      options: SchemaPostOptions,
+      fn: PostMiddlewareFunction<T, T>,
+    ): this;
 
     // method aggregate and insertMany with ErrorHandlingMiddlewareFunction
-    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;
-    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;
-    post<T = TModelType>(method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegExp, fn: ErrorHandlingMiddlewareFunction<T>): this;
-    post<T = TModelType>(method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;
+    post<T extends Aggregate<any>>(
+      method: 'aggregate' | RegExp,
+      fn: ErrorHandlingMiddlewareFunction<T, Array<any>>,
+    ): this;
+    post<T extends Aggregate<any>>(
+      method: 'aggregate' | RegExp,
+      options: SchemaPostOptions,
+      fn: ErrorHandlingMiddlewareFunction<T, Array<any>>,
+    ): this;
+    post<T = TModelType>(
+      method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegExp,
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
+    post<T = TModelType>(
+      method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegExp,
+      options: SchemaPostOptions,
+      fn: ErrorHandlingMiddlewareFunction<T>,
+    ): this;
 
     /** Defines a pre hook for the model. */
     // this = never since it never happens
-    pre<T = never>(method: 'save', options: SchemaPreOptions & { document: false, query: boolean }, fn: PreSaveMiddlewareFunction<T>): this;
-    pre<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: false, query: false }, fn: PreMiddlewareFunction<T>): this;
-    pre<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPreOptions & { document: boolean, query: false }, fn: PreMiddlewareFunction<T>): this;
-    pre<T = never>(method: MongooseDistinctDocumentMiddleware | MongooseDistinctDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: false, query: boolean }, fn: PreMiddlewareFunction<T>): this;
+    pre<T = never>(
+      method: 'save',
+      options: SchemaPreOptions & { document: false; query: boolean },
+      fn: PreSaveMiddlewareFunction<T>,
+    ): this;
+    pre<T = never>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPreOptions & { document: false; query: false },
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = never>(
+      method:
+        | MongooseDistinctQueryMiddleware
+        | MongooseDistinctQueryMiddleware[],
+      options: SchemaPreOptions & { document: boolean; query: false },
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = never>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPreOptions & { document: false; query: boolean },
+      fn: PreMiddlewareFunction<T>,
+    ): this;
     // this = Union of Document and Query, could be called with any of them
     pre<T = THydratedDocumentType | Query<any, any>>(
-      method: MongooseQueryAndDocumentMiddleware | MongooseQueryAndDocumentMiddleware[] | RegExp,
-      options: SchemaPreOptions & { document: true, query: true },
-      fn: PreMiddlewareFunction<T>
+      method:
+        | MongooseQueryAndDocumentMiddleware
+        | MongooseQueryAndDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPreOptions & { document: true; query: true },
+      fn: PreMiddlewareFunction<T>,
     ): this;
     // this = Document
-    pre<T = THydratedDocumentType>(method: 'save', fn: PreSaveMiddlewareFunction<T>): this;
-    pre<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: PreMiddlewareFunction<T>): this;
-    pre<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;
     pre<T = THydratedDocumentType>(
-      method: MongooseQueryAndDocumentMiddleware | MongooseQueryAndDocumentMiddleware[] | RegExp,
+      method: 'save',
+      fn: PreSaveMiddlewareFunction<T>,
+    ): this;
+    pre<T = THydratedDocumentType>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[],
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = THydratedDocumentType>(
+      method:
+        | MongooseDistinctDocumentMiddleware
+        | MongooseDistinctDocumentMiddleware[],
+      options: SchemaPreOptions,
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = THydratedDocumentType>(
+      method:
+        | MongooseQueryAndDocumentMiddleware
+        | MongooseQueryAndDocumentMiddleware[]
+        | RegExp,
       options: SchemaPreOptions & { document: true },
-      fn: PreMiddlewareFunction<T>
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = THydratedDocumentType>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPreOptions & { document: true; query: false },
+      fn: PreMiddlewareFunction<T>,
     ): this;
-    pre<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: true, query: false }, fn: PreMiddlewareFunction<T>): this;
     // this = Query
-    pre<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: PreMiddlewareFunction<T>): this;
-    pre<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;
-    pre<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: false, query: true }, fn: PreMiddlewareFunction<T>): this;
+    pre<T = Query<any, any>>(
+      method: MongooseDefaultQueryMiddleware | MongooseDefaultQueryMiddleware[],
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = Query<any, any>>(
+      method:
+        | MongooseDistinctQueryMiddleware
+        | MongooseDistinctQueryMiddleware[],
+      options: SchemaPreOptions,
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPreOptions & { document: false; query: true },
+      fn: PreMiddlewareFunction<T>,
+    ): this;
     // this = Union of Document and Query, could be called with any of them
-    pre<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, options: SchemaPreOptions & { document: true, query: true }, fn: PreMiddlewareFunction<T>): this;
-    pre<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegExp, fn: PreMiddlewareFunction<T>): this;
+    pre<T = THydratedDocumentType | Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      options: SchemaPreOptions & { document: true; query: true },
+      fn: PreMiddlewareFunction<T>,
+    ): this;
+    pre<T = THydratedDocumentType | Query<any, any>>(
+      method:
+        | MongooseQueryOrDocumentMiddleware
+        | MongooseQueryOrDocumentMiddleware[]
+        | RegExp,
+      fn: PreMiddlewareFunction<T>,
+    ): this;
     // method aggregate
-    pre<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: PreMiddlewareFunction<T>): this;
+    pre<T extends Aggregate<any>>(
+      method: 'aggregate' | RegExp,
+      fn: PreMiddlewareFunction<T>,
+    ): this;
     /* method insertMany */
     pre<T = TModelType>(
       method: 'insertMany' | RegExp,
@@ -458,8 +844,8 @@ declare module 'mongoose' {
         this: T,
         next: (err?: CallbackError) => void,
         docs: any | Array<any>,
-        options?: InsertManyOptions & { lean?: boolean }
-      ) => void | Promise<void>
+        options?: InsertManyOptions & { lean?: boolean },
+      ) => void | Promise<void>,
     ): this;
     /* method bulkWrite */
     pre<T = TModelType>(
@@ -468,8 +854,8 @@ declare module 'mongoose' {
         this: T,
         next: (err?: CallbackError) => void,
         ops: Array<AnyBulkWriteOperation<any>>,
-        options?: mongodb.BulkWriteOptions & MongooseBulkWriteOptions
-      ) => void | Promise<void>
+        options?: mongodb.BulkWriteOptions & MongooseBulkWriteOptions,
+      ) => void | Promise<void>,
     ): this;
     /* method createCollection */
     pre<T = TModelType>(
@@ -477,8 +863,9 @@ declare module 'mongoose' {
       fn: (
         this: T,
         next: (err?: CallbackError) => void,
-        options?: mongodb.CreateCollectionOptions & Pick<SchemaOptions, 'expires'>
-      ) => void | Promise<void>
+        options?: mongodb.CreateCollectionOptions &
+          Pick<SchemaOptions, 'expires'>,
+      ) => void | Promise<void>,
     ): this;
 
     /** Object of currently defined query helpers on this schema. */
@@ -497,21 +884,39 @@ declare module 'mongoose' {
     requiredPaths(invalidate?: boolean): string[];
 
     /** Sets a schema option. */
-    set<K extends keyof SchemaOptions>(key: K, value: SchemaOptions[K], _tags?: any): this;
+    set<K extends keyof SchemaOptions>(
+      key: K,
+      value: SchemaOptions[K],
+      _tags?: any,
+    ): this;
 
     /** Adds static "class" methods to Models compiled from this schema. */
-    static<K extends keyof TStaticMethods>(name: K, fn: TStaticMethods[K]): this;
-    static(obj: { [F in keyof TStaticMethods]: TStaticMethods[F] } & { [name: string]: (this: TModelType, ...args: any[]) => any }): this;
+    static<K extends keyof TStaticMethods>(
+      name: K,
+      fn: TStaticMethods[K],
+    ): this;
+    static(
+      obj: { [F in keyof TStaticMethods]: TStaticMethods[F] } & {
+        [name: string]: (this: TModelType, ...args: any[]) => any;
+      },
+    ): this;
     static(name: string, fn: (this: TModelType, ...args: any[]) => any): this;
 
     /** Object of currently defined statics on this schema. */
-    statics: { [F in keyof TStaticMethods]: TStaticMethods[F] } &
-    { [name: string]: (this: TModelType, ...args: any[]) => unknown };
+    statics: { [F in keyof TStaticMethods]: TStaticMethods[F] } & {
+      [name: string]: (this: TModelType, ...args: any[]) => unknown;
+    };
 
     /** Creates a virtual type with the given name. */
-    virtual<T = HydratedDocument<DocType, TVirtuals & TInstanceMethods, TQueryHelpers>>(
+    virtual<
+      T = HydratedDocument<
+        DocType,
+        TVirtuals & TInstanceMethods,
+        TQueryHelpers
+      >,
+    >(
       name: keyof TVirtuals | string,
-      options?: VirtualTypeOptions<T, DocType>
+      options?: VirtualTypeOptions<T, DocType>,
     ): VirtualType<T>;
 
     /** Object of currently defined virtuals on this schema */
@@ -523,11 +928,30 @@ declare module 'mongoose' {
     static ObjectId: typeof Schema.Types.ObjectId;
   }
 
-  export type NumberSchemaDefinition = typeof Number | 'number' | 'Number' | typeof Schema.Types.Number;
-  export type StringSchemaDefinition = typeof String | 'string' | 'String' | typeof Schema.Types.String;
-  export type BooleanSchemaDefinition = typeof Boolean | 'boolean' | 'Boolean' | typeof Schema.Types.Boolean;
-  export type DateSchemaDefinition = DateConstructor | 'date' | 'Date' | typeof Schema.Types.Date;
-  export type ObjectIdSchemaDefinition = 'ObjectId' | 'ObjectID' | typeof Schema.Types.ObjectId;
+  export type NumberSchemaDefinition =
+    | typeof Number
+    | 'number'
+    | 'Number'
+    | typeof Schema.Types.Number;
+  export type StringSchemaDefinition =
+    | typeof String
+    | 'string'
+    | 'String'
+    | typeof Schema.Types.String;
+  export type BooleanSchemaDefinition =
+    | typeof Boolean
+    | 'boolean'
+    | 'Boolean'
+    | typeof Schema.Types.Boolean;
+  export type DateSchemaDefinition =
+    | DateConstructor
+    | 'date'
+    | 'Date'
+    | typeof Schema.Types.Date;
+  export type ObjectIdSchemaDefinition =
+    | 'ObjectId'
+    | 'ObjectID'
+    | typeof Schema.Types.ObjectId;
 
   export type SchemaDefinitionWithBuiltInClass<T> = T extends number
     ? NumberSchemaDefinition
@@ -537,28 +961,39 @@ declare module 'mongoose' {
         ? BooleanSchemaDefinition
         : T extends NativeDate
           ? DateSchemaDefinition
-          : (Function | string);
-
-  export type SchemaDefinitionProperty<T = undefined, EnforcedDocType = any> = SchemaDefinitionWithBuiltInClass<T> |
-  SchemaTypeOptions<T extends undefined ? any : T, EnforcedDocType> |
-    typeof SchemaType |
-  Schema<any, any, any> |
-  Schema<any, any, any>[] |
-  SchemaTypeOptions<T extends undefined ? any : Unpacked<T>, EnforcedDocType>[] |
-  Function[] |
-  SchemaDefinition<T, EnforcedDocType> |
-  SchemaDefinition<Unpacked<T>, EnforcedDocType>[] |
-    typeof Schema.Types.Mixed |
-  MixedSchemaTypeOptions<EnforcedDocType>;
-
-  export type SchemaDefinition<T = undefined, EnforcedDocType = any> = T extends undefined
-    ? { [path: string]: SchemaDefinitionProperty; }
-    : { [path in keyof T]?: SchemaDefinitionProperty<T[path], EnforcedDocType>; };
+          : Function | string;
+
+  export type SchemaDefinitionProperty<T = undefined, EnforcedDocType = any> =
+    | SchemaDefinitionWithBuiltInClass<T>
+    | SchemaTypeOptions<T extends undefined ? any : T, EnforcedDocType>
+    | typeof SchemaType
+    | Schema<any, any, any>
+    | Schema<any, any, any>[]
+    | SchemaTypeOptions<
+        T extends undefined ? any : Unpacked<T>,
+        EnforcedDocType
+      >[]
+    | Function[]
+    | SchemaDefinition<T, EnforcedDocType>
+    | SchemaDefinition<Unpacked<T>, EnforcedDocType>[]
+    | typeof Schema.Types.Mixed
+    | MixedSchemaTypeOptions<EnforcedDocType>;
+
+  export type SchemaDefinition<
+    T = undefined,
+    EnforcedDocType = any,
+  > = T extends undefined
+    ? { [path: string]: SchemaDefinitionProperty }
+    : {
+        [path in keyof T]?: SchemaDefinitionProperty<T[path], EnforcedDocType>;
+      };
 
   export type AnyArray<T> = T[] | ReadonlyArray<T>;
-  export type ExtractMongooseArray<T> = T extends Types.Array<any> ? AnyArray<Unpacked<T>> : T;
+  export type ExtractMongooseArray<T> =
+    T extends Types.Array<any> ? AnyArray<Unpacked<T>> : T;
 
-  export interface MixedSchemaTypeOptions<EnforcedDocType> extends SchemaTypeOptions<Schema.Types.Mixed, EnforcedDocType> {
+  export interface MixedSchemaTypeOptions<EnforcedDocType>
+    extends SchemaTypeOptions<Schema.Types.Mixed, EnforcedDocType> {
     type: typeof Schema.Types.Mixed;
   }
 
@@ -574,18 +1009,24 @@ declare module 'mongoose' {
     | typeof Schema.Types.Buffer
     | typeof Schema.Types.ObjectId;
 
-
   export type InferId<T> = T extends { _id?: any } ? T['_id'] : Types.ObjectId;
 
-  export interface VirtualTypeOptions<HydratedDocType = Document, DocType = unknown> {
+  export interface VirtualTypeOptions<
+    HydratedDocType = Document,
+    DocType = unknown,
+  > {
     /** If `ref` is not nullish, this becomes a populated virtual. */
     ref?: string | Function;
 
     /** The local field to populate on if this is a populated virtual. */
-    localField?: string | ((this: HydratedDocType, doc: HydratedDocType) => string);
+    localField?:
+      | string
+      | ((this: HydratedDocType, doc: HydratedDocType) => string);
 
     /** The foreign field to populate on if this is a populated virtual. */
-    foreignField?: string | ((this: HydratedDocType, doc: HydratedDocType) => string);
+    foreignField?:
+      | string
+      | ((this: HydratedDocType, doc: HydratedDocType) => string);
 
     /**
      * By default, a populated virtual is an array. If you set `justOne`,
@@ -603,7 +1044,12 @@ declare module 'mongoose' {
     count?: boolean;
 
     /** Add an extra match condition to `populate()`. */
-    match?: FilterQuery<any> | ((doc: Record<string, any>, virtual?: this) => Record<string, any> | null);
+    match?:
+      | FilterQuery<any>
+      | ((
+          doc: Record<string, any>,
+          virtual?: this,
+        ) => Record<string, any> | null);
 
     /** Add a default `limit` to the `populate()` query. */
     limit?: number;
@@ -638,16 +1084,26 @@ declare module 'mongoose' {
     applySetters(value: any, doc: Document): any;
 
     /** Adds a custom getter to this virtual. */
-    get<T = HydratedDocType>(fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => any): this;
+    get<T = HydratedDocType>(
+      fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => any,
+    ): this;
 
     /** Adds a custom setter to this virtual. */
-    set<T = HydratedDocType>(fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => void): this;
+    set<T = HydratedDocType>(
+      fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => void,
+    ): this;
   }
 
-  export type ReturnsNewDoc = { new: true } | { returnOriginal: false } | { returnDocument: 'after' };
+  export type ReturnsNewDoc =
+    | { new: true }
+    | { returnOriginal: false }
+    | { returnDocument: 'after' };
 
   export type ProjectionElementType = number | string;
-  export type ProjectionType<T> = { [P in keyof T]?: ProjectionElementType } | AnyObject | string;
+  export type ProjectionType<T> =
+    | { [P in keyof T]?: ProjectionElementType }
+    | AnyObject
+    | string;
 
   export type SortValues = SortOrder;
 
@@ -677,12 +1133,13 @@ declare module 'mongoose' {
   };
 
   export type UpdateWithAggregationPipeline = UpdateAggregationStage[];
-  export type UpdateAggregationStage = { $addFields: any } |
-  { $set: any } |
-  { $project: any } |
-  { $unset: any } |
-  { $replaceRoot: any } |
-  { $replaceWith: any };
+  export type UpdateAggregationStage =
+    | { $addFields: any }
+    | { $set: any }
+    | { $project: any }
+    | { $unset: any }
+    | { $replaceRoot: any }
+    | { $replaceWith: any };
 
   /**
    * Update query command to perform on the document
@@ -712,111 +1169,174 @@ declare module 'mongoose' {
   /**
    * Converts any Buffer properties into mongodb.Binary instances, which is what `lean()` returns
    */
-  export type BufferToBinary<T> = T extends TreatAsPrimitives ? T : T extends Record<string, any> ? {
-    [K in keyof T]: T[K] extends Buffer
-      ? mongodb.Binary
-      : T[K] extends (Buffer | null | undefined)
-        ? mongodb.Binary | null | undefined
-        : T[K] extends Types.DocumentArray<infer ItemType>
-            ? Types.DocumentArray<BufferToBinary<ItemType>>
-            : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
-              ? HydratedSingleSubdocument<SubdocType>
-              : BufferToBinary<T[K]>;
-  } : T;
+  export type BufferToBinary<T> = T extends TreatAsPrimitives
+    ? T
+    : T extends Record<string, any>
+      ? {
+          [K in keyof T]: T[K] extends Buffer
+            ? mongodb.Binary
+            : T[K] extends Buffer | null | undefined
+              ? mongodb.Binary | null | undefined
+              : T[K] extends Types.DocumentArray<infer ItemType>
+                ? Types.DocumentArray<BufferToBinary<ItemType>>
+                : T[K] extends Types.Subdocument<
+                      unknown,
+                      unknown,
+                      infer SubdocType
+                    >
+                  ? HydratedSingleSubdocument<SubdocType>
+                  : BufferToBinary<T[K]>;
+        }
+      : T;
 
   /**
    * Converts any Buffer properties into { type: 'buffer', data: [1, 2, 3] } format for JSON serialization
    */
-  export type BufferToJSON<T> = T extends TreatAsPrimitives ? T : T extends Record<string, any> ? {
-    [K in keyof T]: T[K] extends Buffer
-      ? { type: 'buffer', data: number[] }
-      : T[K] extends (Buffer | null | undefined)
-        ? { type: 'buffer', data: number[] } | null | undefined
-        : T[K] extends Types.DocumentArray<infer ItemType>
-            ? Types.DocumentArray<BufferToBinary<ItemType>>
-            : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
-              ? HydratedSingleSubdocument<SubdocType>
-              : BufferToBinary<T[K]>;
-  } : T;
+  export type BufferToJSON<T> = T extends TreatAsPrimitives
+    ? T
+    : T extends Record<string, any>
+      ? {
+          [K in keyof T]: T[K] extends Buffer
+            ? { type: 'buffer'; data: number[] }
+            : T[K] extends Buffer | null | undefined
+              ? { type: 'buffer'; data: number[] } | null | undefined
+              : T[K] extends Types.DocumentArray<infer ItemType>
+                ? Types.DocumentArray<BufferToBinary<ItemType>>
+                : T[K] extends Types.Subdocument<
+                      unknown,
+                      unknown,
+                      infer SubdocType
+                    >
+                  ? HydratedSingleSubdocument<SubdocType>
+                  : BufferToBinary<T[K]>;
+        }
+      : T;
 
   /**
    * Converts any ObjectId properties into strings for JSON serialization
    */
-  export type ObjectIdToString<T> = T extends TreatAsPrimitives ? T : T extends Record<string, any> ? {
-    [K in keyof T]: T[K] extends mongodb.ObjectId
-      ? string
-      : T[K] extends (mongodb.ObjectId | null | undefined)
-        ? string | null | undefined
-        : T[K] extends Types.DocumentArray<infer ItemType>
-            ? Types.DocumentArray<ObjectIdToString<ItemType>>
-            : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
-              ? HydratedSingleSubdocument<ObjectIdToString<SubdocType>>
-              : ObjectIdToString<T[K]>;
-  } : T;
+  export type ObjectIdToString<T> = T extends TreatAsPrimitives
+    ? T
+    : T extends Record<string, any>
+      ? {
+          [K in keyof T]: T[K] extends mongodb.ObjectId
+            ? string
+            : T[K] extends mongodb.ObjectId | null | undefined
+              ? string | null | undefined
+              : T[K] extends Types.DocumentArray<infer ItemType>
+                ? Types.DocumentArray<ObjectIdToString<ItemType>>
+                : T[K] extends Types.Subdocument<
+                      unknown,
+                      unknown,
+                      infer SubdocType
+                    >
+                  ? HydratedSingleSubdocument<ObjectIdToString<SubdocType>>
+                  : ObjectIdToString<T[K]>;
+        }
+      : T;
 
   /**
    * Converts any Date properties into strings for JSON serialization
    */
-  export type DateToString<T> = T extends TreatAsPrimitives ? T : T extends Record<string, any> ? {
-    [K in keyof T]: T[K] extends NativeDate
-      ? string
-      : T[K] extends (NativeDate | null | undefined)
-        ? string | null | undefined
-        : T[K] extends Types.DocumentArray<infer ItemType>
-            ? Types.DocumentArray<DateToString<ItemType>>
-            : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
-              ? HydratedSingleSubdocument<DateToString<SubdocType>>
-              : DateToString<T[K]>;
-  } : T;
+  export type DateToString<T> = T extends TreatAsPrimitives
+    ? T
+    : T extends Record<string, any>
+      ? {
+          [K in keyof T]: T[K] extends NativeDate
+            ? string
+            : T[K] extends NativeDate | null | undefined
+              ? string | null | undefined
+              : T[K] extends Types.DocumentArray<infer ItemType>
+                ? Types.DocumentArray<DateToString<ItemType>>
+                : T[K] extends Types.Subdocument<
+                      unknown,
+                      unknown,
+                      infer SubdocType
+                    >
+                  ? HydratedSingleSubdocument<DateToString<SubdocType>>
+                  : DateToString<T[K]>;
+        }
+      : T;
 
   /**
    * Converts any Mongoose subdocuments (single nested or doc arrays) into POJO equivalents
    */
-  export type SubdocsToPOJOs<T> = T extends TreatAsPrimitives ? T : T extends Record<string, any> ? {
-    [K in keyof T]: T[K] extends NativeDate
-      ? string
-      : T[K] extends (NativeDate | null | undefined)
-        ? string | null | undefined
-        : T[K] extends Types.DocumentArray<infer ItemType>
-            ? ItemType[]
-            : T[K] extends Types.Subdocument<unknown, unknown, infer SubdocType>
-              ? SubdocType
-              : SubdocsToPOJOs<T[K]>;
-  } : T;
+  export type SubdocsToPOJOs<T> = T extends TreatAsPrimitives
+    ? T
+    : T extends Record<string, any>
+      ? {
+          [K in keyof T]: T[K] extends NativeDate
+            ? string
+            : T[K] extends NativeDate | null | undefined
+              ? string | null | undefined
+              : T[K] extends Types.DocumentArray<infer ItemType>
+                ? ItemType[]
+                : T[K] extends Types.Subdocument<
+                      unknown,
+                      unknown,
+                      infer SubdocType
+                    >
+                  ? SubdocType
+                  : SubdocsToPOJOs<T[K]>;
+        }
+      : T;
 
   export type JSONSerialized<T> = SubdocsToPOJOs<
-    FlattenMaps<
-      BufferToJSON<
-        ObjectIdToString<
-          DateToString<T>
-        >
-      >
-    >
+    FlattenMaps<BufferToJSON<ObjectIdToString<DateToString<T>>>>
   >;
 
   /**
    * Separate type is needed for properties of union type (for example, Types.DocumentArray | undefined) to apply conditional check to each member of it
    * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types
    */
-  type FlattenProperty<T> = T extends Map<any, infer V>
-    ? Record<string, V> : T extends TreatAsPrimitives
-      ? T : T extends Types.DocumentArray<infer ItemType>
-        ? Types.DocumentArray<FlattenMaps<ItemType>> : FlattenMaps<T>;
-
-  export type actualPrimitives = string | boolean | number | bigint | symbol | null | undefined;
-  export type TreatAsPrimitives = actualPrimitives | NativeDate | RegExp | symbol | Error | BigInt | Types.ObjectId | Buffer | Function | mongodb.Binary;
+  type FlattenProperty<T> =
+    T extends Map<any, infer V>
+      ? Record<string, V>
+      : T extends TreatAsPrimitives
+        ? T
+        : T extends Types.DocumentArray<infer ItemType>
+          ? Types.DocumentArray<FlattenMaps<ItemType>>
+          : FlattenMaps<T>;
+
+  export type actualPrimitives =
+    | string
+    | boolean
+    | number
+    | bigint
+    | symbol
+    | null
+    | undefined;
+  export type TreatAsPrimitives =
+    | actualPrimitives
+    | NativeDate
+    | RegExp
+    | symbol
+    | Error
+    | BigInt
+    | Types.ObjectId
+    | Buffer
+    | Function
+    | mongodb.Binary;
 
-  export type SchemaDefinitionType<T> = T extends Document ? Omit<T, Exclude<keyof Document, '_id' | 'id' | '__v'>> : T;
+  export type SchemaDefinitionType<T> = T extends Document
+    ? Omit<T, Exclude<keyof Document, '_id' | 'id' | '__v'>>
+    : T;
 
   /**
    * Helper to choose the best option between two type helpers
    */
-  export type _pickObject<T1, T2, Fallback> = T1 extends false ? T2 extends false ? Fallback : T2 : T1;
+  export type _pickObject<T1, T2, Fallback> = T1 extends false
+    ? T2 extends false
+      ? Fallback
+      : T2
+    : T1;
 
   /* for ts-mongoose */
-  export class mquery { }
+  export class mquery {}
 
-  export function overwriteMiddlewareResult(val: any): Kareem.OverwriteMiddlewareResult;
+  export function overwriteMiddlewareResult(
+    val: any,
+  ): Kareem.OverwriteMiddlewareResult;
 
   export function skipMiddlewareFunction(val: any): Kareem.SkipWrappedFunction;
 
diff --git a/types/indexes.d.ts b/types/indexes.d.ts
index 805705905a23938d47468535856c287e8d145ff9..21396bf839d890d4d99753395361de670319c710 100644
--- a/types/indexes.d.ts
+++ b/types/indexes.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   /**
@@ -7,7 +7,9 @@ declare module 'mongoose' {
    * the model's schema except the `_id` index, and build any indexes that
    * are in your schema but not in MongoDB.
    */
-  function syncIndexes(options?: SyncIndexesOptions): Promise<ConnectionSyncIndexesResult>;
+  function syncIndexes(
+    options?: SyncIndexesOptions,
+  ): Promise<ConnectionSyncIndexesResult>;
 
   interface IndexManager {
     /**
@@ -21,7 +23,7 @@ declare module 'mongoose' {
      * the result of this function would be the result of
      * Model.syncIndexes().
      */
-    diffIndexes(options?: Record<string, unknown>): Promise<IndexesDiff>
+    diffIndexes(options?: Record<string, unknown>): Promise<IndexesDiff>;
 
     /**
      * Sends `createIndex` commands to mongo for each index declared in the schema.
@@ -48,20 +50,35 @@ declare module 'mongoose' {
 
   interface IndexesDiff {
     /** Indexes that would be created in mongodb. */
-    toCreate: Array<any>
+    toCreate: Array<any>;
     /** Indexes that would be dropped in mongodb. */
-    toDrop: Array<any>
+    toDrop: Array<any>;
   }
 
-  type IndexDirection = 1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text' | 'ascending' | 'asc' | 'descending' | 'desc';
+  type IndexDirection =
+    | 1
+    | -1
+    | '2d'
+    | '2dsphere'
+    | 'geoHaystack'
+    | 'hashed'
+    | 'text'
+    | 'ascending'
+    | 'asc'
+    | 'descending'
+    | 'desc';
   type IndexDefinition = Record<string, IndexDirection>;
 
   interface SyncIndexesOptions extends mongodb.CreateIndexesOptions {
     continueOnError?: boolean;
     hideIndexes?: boolean;
   }
-  type ConnectionSyncIndexesResult = Record<string, OneCollectionSyncIndexesResult>;
-  type OneCollectionSyncIndexesResult = Array<string> & mongodb.MongoServerError;
+  type ConnectionSyncIndexesResult = Record<
+    string,
+    OneCollectionSyncIndexesResult
+  >;
+  type OneCollectionSyncIndexesResult = Array<string> &
+    mongodb.MongoServerError;
 
   interface IndexOptions extends mongodb.CreateIndexesOptions {
     /**
diff --git a/types/inferrawdoctype.d.ts b/types/inferrawdoctype.d.ts
index 605571057a04da06e3ecd693d36d1776af134af8..ce9a562115b0cc5e65fb310a7df31044e149e4b0 100644
--- a/types/inferrawdoctype.d.ts
+++ b/types/inferrawdoctype.d.ts
@@ -4,21 +4,31 @@ import {
   RequiredPaths,
   OptionalPaths,
   PathWithTypePropertyBaseType,
-  PathEnumOrString
+  PathEnumOrString,
 } from './inferschematype';
 
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   export type InferRawDocType<
     DocDefinition,
-    TSchemaOptions extends Record<any, any> = DefaultSchemaOptions
-  > = ApplySchemaOptions<{
-    [
-    K in keyof (RequiredPaths<DocDefinition, TSchemaOptions['typeKey']> &
-    OptionalPaths<DocDefinition, TSchemaOptions['typeKey']>)
-    ]: IsPathRequired<DocDefinition[K], TSchemaOptions['typeKey']> extends true
-      ? ObtainRawDocumentPathType<DocDefinition[K], TSchemaOptions['typeKey']>
-      : ObtainRawDocumentPathType<DocDefinition[K], TSchemaOptions['typeKey']> | null;
-  }, TSchemaOptions>;
+    TSchemaOptions extends Record<any, any> = DefaultSchemaOptions,
+  > = ApplySchemaOptions<
+    {
+      [K in keyof (RequiredPaths<DocDefinition, TSchemaOptions['typeKey']> &
+        OptionalPaths<
+          DocDefinition,
+          TSchemaOptions['typeKey']
+        >)]: IsPathRequired<
+        DocDefinition[K],
+        TSchemaOptions['typeKey']
+      > extends true
+        ? ObtainRawDocumentPathType<DocDefinition[K], TSchemaOptions['typeKey']>
+        : ObtainRawDocumentPathType<
+            DocDefinition[K],
+            TSchemaOptions['typeKey']
+          > | null;
+    },
+    TSchemaOptions
+  >;
 
   /**
    * @summary Obtains schema Path type.
@@ -28,10 +38,14 @@ declare module 'mongoose' {
    */
   type ObtainRawDocumentPathType<
     PathValueType,
-    TypeKey extends string = DefaultTypeKey
+    TypeKey extends string = DefaultTypeKey,
   > = ResolveRawPathType<
-    PathValueType extends PathWithTypePropertyBaseType<TypeKey> ? PathValueType[TypeKey] : PathValueType,
-    PathValueType extends PathWithTypePropertyBaseType<TypeKey> ? Omit<PathValueType, TypeKey> : {},
+    PathValueType extends PathWithTypePropertyBaseType<TypeKey>
+      ? PathValueType[TypeKey]
+      : PathValueType,
+    PathValueType extends PathWithTypePropertyBaseType<TypeKey>
+      ? Omit<PathValueType, TypeKey>
+      : {},
     TypeKey
   >;
 
@@ -48,72 +62,184 @@ declare module 'mongoose' {
    * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
    * @returns Number, "Number" or "number" will be resolved to number type.
    */
-  type ResolveRawPathType<PathValueType, Options extends SchemaTypeOptions<PathValueType> = {}, TypeKey extends string = DefaultSchemaOptions['typeKey']> =
-  PathValueType extends Schema ?
-    InferSchemaType<PathValueType> :
-    PathValueType extends (infer Item)[] ?
-      IfEquals<Item, never, any[], Item extends Schema ?
-        // If Item is a schema, infer its type.
-        Array<InferSchemaType<Item>> :
-        Item extends Record<TypeKey, any> ?
-          Item[TypeKey] extends Function | String ?
-            // If Item has a type key that's a string or a callable, it must be a scalar,
-            // so we can directly obtain its path type.
-            ObtainRawDocumentPathType<Item, TypeKey>[] :
-            // If the type key isn't callable, then this is an array of objects, in which case
-            // we need to call ObtainDocumentType to correctly infer its type.
-            Array<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
-          IsSchemaTypeFromBuiltinClass<Item> extends true ?
-            ObtainRawDocumentPathType<Item, TypeKey>[] :
-            IsItRecordAndNotAny<Item> extends true ?
-              Item extends Record<string, never> ?
-                ObtainRawDocumentPathType<Item, TypeKey>[] :
-                Array<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
-              ObtainRawDocumentPathType<Item, TypeKey>[]
-      >:
-      PathValueType extends ReadonlyArray<infer Item> ?
-        IfEquals<Item, never, any[], Item extends Schema ?
-          Array<InferSchemaType<Item>> :
-          Item extends Record<TypeKey, any> ?
-            Item[TypeKey] extends Function | String ?
-              ObtainRawDocumentPathType<Item, TypeKey>[] :
-              ObtainDocumentType<Item, any, { typeKey: TypeKey }>[]:
-            IsSchemaTypeFromBuiltinClass<Item> extends true ?
-              ObtainRawDocumentPathType<Item, TypeKey>[] :
-              IsItRecordAndNotAny<Item> extends true ?
-                Item extends Record<string, never> ?
-                  ObtainRawDocumentPathType<Item, TypeKey>[] :
-                  Array<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
-                ObtainRawDocumentPathType<Item, TypeKey>[]
-        >:
-        PathValueType extends StringSchemaDefinition ? PathEnumOrString<Options['enum']> :
-          IfEquals<PathValueType, Schema.Types.String> extends true ? PathEnumOrString<Options['enum']> :
-            IfEquals<PathValueType, String> extends true ? PathEnumOrString<Options['enum']> :
-              PathValueType extends NumberSchemaDefinition ? Options['enum'] extends ReadonlyArray<any> ? Options['enum'][number] : number :
-                IfEquals<PathValueType, Schema.Types.Number> extends true ? number :
-                  PathValueType extends DateSchemaDefinition ? NativeDate :
-                    IfEquals<PathValueType, Schema.Types.Date> extends true ? NativeDate :
-                      PathValueType extends typeof Buffer | 'buffer' | 'Buffer' | typeof Schema.Types.Buffer ? Buffer :
-                        PathValueType extends BooleanSchemaDefinition ? boolean :
-                          IfEquals<PathValueType, Schema.Types.Boolean> extends true ? boolean :
-                            PathValueType extends ObjectIdSchemaDefinition ? Types.ObjectId :
-                              IfEquals<PathValueType, Types.ObjectId> extends true ? Types.ObjectId :
-                                IfEquals<PathValueType, Schema.Types.ObjectId> extends true ? Types.ObjectId :
-                                  PathValueType extends 'decimal128' | 'Decimal128' | typeof Schema.Types.Decimal128 ? Types.Decimal128 :
-                                    IfEquals<PathValueType, Schema.Types.Decimal128> extends true ? Types.Decimal128 :
-                                      IfEquals<PathValueType, Types.Decimal128> extends true ? Types.Decimal128 :
-                                        IfEquals<PathValueType, Schema.Types.BigInt> extends true ? bigint :
-                                          IfEquals<PathValueType, BigInt> extends true ? bigint :
-                                            PathValueType extends 'bigint' | 'BigInt' | typeof Schema.Types.BigInt | typeof BigInt ? bigint :
-                                              PathValueType extends 'uuid' | 'UUID' | typeof Schema.Types.UUID ? Buffer :
-                                                IfEquals<PathValueType, Schema.Types.UUID> extends true ? Buffer :
-                                                  PathValueType extends MapConstructor | 'Map' ? Map<string, ResolveRawPathType<Options['of']>> :
-                                                    IfEquals<PathValueType, typeof Schema.Types.Map> extends true ? Map<string, ResolveRawPathType<Options['of']>> :
-                                                      PathValueType extends ArrayConstructor ? any[] :
-                                                        PathValueType extends typeof Schema.Types.Mixed ? any:
-                                                          IfEquals<PathValueType, ObjectConstructor> extends true ? any:
-                                                            IfEquals<PathValueType, {}> extends true ? any:
-                                                              PathValueType extends typeof SchemaType ? PathValueType['prototype'] :
-                                                                PathValueType extends Record<string, any> ? ObtainDocumentType<PathValueType, any, { typeKey: TypeKey }> :
-                                                                  unknown;
+  type ResolveRawPathType<
+    PathValueType,
+    Options extends SchemaTypeOptions<PathValueType> = {},
+    TypeKey extends string = DefaultSchemaOptions['typeKey'],
+  > = PathValueType extends Schema
+    ? InferSchemaType<PathValueType>
+    : PathValueType extends (infer Item)[]
+      ? IfEquals<
+          Item,
+          never,
+          any[],
+          Item extends Schema
+            ? // If Item is a schema, infer its type.
+              Array<InferSchemaType<Item>>
+            : Item extends Record<TypeKey, any>
+              ? Item[TypeKey] extends Function | String
+                ? // If Item has a type key that's a string or a callable, it must be a scalar,
+                  // so we can directly obtain its path type.
+                  ObtainRawDocumentPathType<Item, TypeKey>[]
+                : // If the type key isn't callable, then this is an array of objects, in which case
+                  // we need to call ObtainDocumentType to correctly infer its type.
+                  Array<ObtainDocumentType<Item, any, { typeKey: TypeKey }>>
+              : IsSchemaTypeFromBuiltinClass<Item> extends true
+                ? ObtainRawDocumentPathType<Item, TypeKey>[]
+                : IsItRecordAndNotAny<Item> extends true
+                  ? Item extends Record<string, never>
+                    ? ObtainRawDocumentPathType<Item, TypeKey>[]
+                    : Array<ObtainDocumentType<Item, any, { typeKey: TypeKey }>>
+                  : ObtainRawDocumentPathType<Item, TypeKey>[]
+        >
+      : PathValueType extends ReadonlyArray<infer Item>
+        ? IfEquals<
+            Item,
+            never,
+            any[],
+            Item extends Schema
+              ? Array<InferSchemaType<Item>>
+              : Item extends Record<TypeKey, any>
+                ? Item[TypeKey] extends Function | String
+                  ? ObtainRawDocumentPathType<Item, TypeKey>[]
+                  : ObtainDocumentType<Item, any, { typeKey: TypeKey }>[]
+                : IsSchemaTypeFromBuiltinClass<Item> extends true
+                  ? ObtainRawDocumentPathType<Item, TypeKey>[]
+                  : IsItRecordAndNotAny<Item> extends true
+                    ? Item extends Record<string, never>
+                      ? ObtainRawDocumentPathType<Item, TypeKey>[]
+                      : Array<
+                          ObtainDocumentType<Item, any, { typeKey: TypeKey }>
+                        >
+                    : ObtainRawDocumentPathType<Item, TypeKey>[]
+          >
+        : PathValueType extends StringSchemaDefinition
+          ? PathEnumOrString<Options['enum']>
+          : IfEquals<PathValueType, Schema.Types.String> extends true
+            ? PathEnumOrString<Options['enum']>
+            : IfEquals<PathValueType, String> extends true
+              ? PathEnumOrString<Options['enum']>
+              : PathValueType extends NumberSchemaDefinition
+                ? Options['enum'] extends ReadonlyArray<any>
+                  ? Options['enum'][number]
+                  : number
+                : IfEquals<PathValueType, Schema.Types.Number> extends true
+                  ? number
+                  : PathValueType extends DateSchemaDefinition
+                    ? NativeDate
+                    : IfEquals<PathValueType, Schema.Types.Date> extends true
+                      ? NativeDate
+                      : PathValueType extends
+                            | typeof Buffer
+                            | 'buffer'
+                            | 'Buffer'
+                            | typeof Schema.Types.Buffer
+                        ? Buffer
+                        : PathValueType extends BooleanSchemaDefinition
+                          ? boolean
+                          : IfEquals<
+                                PathValueType,
+                                Schema.Types.Boolean
+                              > extends true
+                            ? boolean
+                            : PathValueType extends ObjectIdSchemaDefinition
+                              ? Types.ObjectId
+                              : IfEquals<
+                                    PathValueType,
+                                    Types.ObjectId
+                                  > extends true
+                                ? Types.ObjectId
+                                : IfEquals<
+                                      PathValueType,
+                                      Schema.Types.ObjectId
+                                    > extends true
+                                  ? Types.ObjectId
+                                  : PathValueType extends
+                                        | 'decimal128'
+                                        | 'Decimal128'
+                                        | typeof Schema.Types.Decimal128
+                                    ? Types.Decimal128
+                                    : IfEquals<
+                                          PathValueType,
+                                          Schema.Types.Decimal128
+                                        > extends true
+                                      ? Types.Decimal128
+                                      : IfEquals<
+                                            PathValueType,
+                                            Types.Decimal128
+                                          > extends true
+                                        ? Types.Decimal128
+                                        : IfEquals<
+                                              PathValueType,
+                                              Schema.Types.BigInt
+                                            > extends true
+                                          ? bigint
+                                          : IfEquals<
+                                                PathValueType,
+                                                BigInt
+                                              > extends true
+                                            ? bigint
+                                            : PathValueType extends
+                                                  | 'bigint'
+                                                  | 'BigInt'
+                                                  | typeof Schema.Types.BigInt
+                                                  | typeof BigInt
+                                              ? bigint
+                                              : PathValueType extends
+                                                    | 'uuid'
+                                                    | 'UUID'
+                                                    | typeof Schema.Types.UUID
+                                                ? Buffer
+                                                : IfEquals<
+                                                      PathValueType,
+                                                      Schema.Types.UUID
+                                                    > extends true
+                                                  ? Buffer
+                                                  : PathValueType extends
+                                                        | MapConstructor
+                                                        | 'Map'
+                                                    ? Map<
+                                                        string,
+                                                        ResolveRawPathType<
+                                                          Options['of']
+                                                        >
+                                                      >
+                                                    : IfEquals<
+                                                          PathValueType,
+                                                          typeof Schema.Types.Map
+                                                        > extends true
+                                                      ? Map<
+                                                          string,
+                                                          ResolveRawPathType<
+                                                            Options['of']
+                                                          >
+                                                        >
+                                                      : PathValueType extends ArrayConstructor
+                                                        ? any[]
+                                                        : PathValueType extends typeof Schema.Types.Mixed
+                                                          ? any
+                                                          : IfEquals<
+                                                                PathValueType,
+                                                                ObjectConstructor
+                                                              > extends true
+                                                            ? any
+                                                            : IfEquals<
+                                                                  PathValueType,
+                                                                  {}
+                                                                > extends true
+                                                              ? any
+                                                              : PathValueType extends typeof SchemaType
+                                                                ? PathValueType['prototype']
+                                                                : PathValueType extends Record<
+                                                                      string,
+                                                                      any
+                                                                    >
+                                                                  ? ObtainDocumentType<
+                                                                      PathValueType,
+                                                                      any,
+                                                                      {
+                                                                        typeKey: TypeKey;
+                                                                      }
+                                                                    >
+                                                                  : unknown;
 }
diff --git a/types/inferschematype.d.ts b/types/inferschematype.d.ts
index d73ad4cb81c4eff6502ae240b48d234d1098739b..77b1a3b901a8db48aa46f51ebb16eca81a54de0c 100644
--- a/types/inferschematype.d.ts
+++ b/types/inferschematype.d.ts
@@ -14,10 +14,10 @@ import {
   ObjectIdSchemaDefinition,
   IfEquals,
   DefaultSchemaOptions,
-  IsItRecordAndNotAny
+  IsItRecordAndNotAny,
 } from 'mongoose';
 
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   /**
    * @summary Obtains document schema type.
    * @description Obtains document schema type from document Definition OR returns enforced schema type if it's provided.
@@ -28,17 +28,28 @@ declare module 'mongoose' {
   type ObtainDocumentType<
     DocDefinition,
     EnforcedDocType = any,
-    TSchemaOptions extends Record<any, any> = DefaultSchemaOptions
-  > = IsItRecordAndNotAny<EnforcedDocType> extends true ?
-    EnforcedDocType :
-    {
-      [
-      K in keyof (RequiredPaths<DocDefinition, TSchemaOptions['typeKey']> &
-      OptionalPaths<DocDefinition, TSchemaOptions['typeKey']>)
-      ]: IsPathRequired<DocDefinition[K], TSchemaOptions['typeKey']> extends true ?
-        ObtainDocumentPathType<DocDefinition[K], TSchemaOptions['typeKey']> :
-        ObtainDocumentPathType<DocDefinition[K], TSchemaOptions['typeKey']> | null;
-    };
+    TSchemaOptions extends Record<any, any> = DefaultSchemaOptions,
+  > =
+    IsItRecordAndNotAny<EnforcedDocType> extends true
+      ? EnforcedDocType
+      : {
+          [K in keyof (RequiredPaths<DocDefinition, TSchemaOptions['typeKey']> &
+            OptionalPaths<
+              DocDefinition,
+              TSchemaOptions['typeKey']
+            >)]: IsPathRequired<
+            DocDefinition[K],
+            TSchemaOptions['typeKey']
+          > extends true
+            ? ObtainDocumentPathType<
+                DocDefinition[K],
+                TSchemaOptions['typeKey']
+              >
+            : ObtainDocumentPathType<
+                DocDefinition[K],
+                TSchemaOptions['typeKey']
+              > | null;
+        };
 
   /**
    * @summary Obtains document schema type from Schema instance.
@@ -49,86 +60,123 @@ declare module 'mongoose' {
    * // result
    * type UserType = {userName?: string}
    */
-  export type InferSchemaType<TSchema> = IfAny<TSchema, any, ObtainSchemaGeneric<TSchema, 'DocType'>>;
+  export type InferSchemaType<TSchema> = IfAny<
+    TSchema,
+    any,
+    ObtainSchemaGeneric<TSchema, 'DocType'>
+  >;
 
   /**
    * @summary Obtains schema Generic type by using generic alias.
    * @param {TSchema} TSchema A generic of schema type instance.
    * @param {alias} alias Targeted generic alias.
    */
-  type ObtainSchemaGeneric<TSchema, alias extends 'EnforcedDocType' | 'M' | 'TInstanceMethods' | 'TQueryHelpers' | 'TVirtuals' | 'TStaticMethods' | 'TSchemaOptions' | 'DocType'> =
-   TSchema extends Schema<infer EnforcedDocType, infer M, infer TInstanceMethods, infer TQueryHelpers, infer TVirtuals, infer TStaticMethods, infer TSchemaOptions, infer DocType>
-     ? {
-       EnforcedDocType: EnforcedDocType;
-       M: M;
-       TInstanceMethods: TInstanceMethods;
-       TQueryHelpers: TQueryHelpers;
-       TVirtuals: TVirtuals;
-       TStaticMethods: TStaticMethods;
-       TSchemaOptions: TSchemaOptions;
-       DocType: DocType;
-     }[alias]
-     : unknown;
+  type ObtainSchemaGeneric<
+    TSchema,
+    alias extends
+      | 'EnforcedDocType'
+      | 'M'
+      | 'TInstanceMethods'
+      | 'TQueryHelpers'
+      | 'TVirtuals'
+      | 'TStaticMethods'
+      | 'TSchemaOptions'
+      | 'DocType',
+  > =
+    TSchema extends Schema<
+      infer EnforcedDocType,
+      infer M,
+      infer TInstanceMethods,
+      infer TQueryHelpers,
+      infer TVirtuals,
+      infer TStaticMethods,
+      infer TSchemaOptions,
+      infer DocType
+    >
+      ? {
+          EnforcedDocType: EnforcedDocType;
+          M: M;
+          TInstanceMethods: TInstanceMethods;
+          TQueryHelpers: TQueryHelpers;
+          TVirtuals: TVirtuals;
+          TStaticMethods: TStaticMethods;
+          TSchemaOptions: TSchemaOptions;
+          DocType: DocType;
+        }[alias]
+      : unknown;
 
   type ResolveSchemaOptions<T> = MergeType<DefaultSchemaOptions, T>;
 
-  type ApplySchemaOptions<T, O = DefaultSchemaOptions> = ResolveTimestamps<T, O>;
+  type ApplySchemaOptions<T, O = DefaultSchemaOptions> = ResolveTimestamps<
+    T,
+    O
+  >;
 
-  type ResolveTimestamps<T, O> = O extends { methods: any } | { statics: any } | { virtuals: any } | { timestamps?: false } ? T
-    // For some reason, TypeScript sets all the document properties to unknown
-    // if we use methods, statics, or virtuals. So avoid inferring timestamps
-    // if any of these are set for now. See gh-12807
-    : O extends { timestamps: infer TimestampOptions } ? TimestampOptions extends true
-      ? { createdAt: NativeDate; updatedAt: NativeDate; } & T
-      : TimestampOptions extends SchemaTimestampsConfig
-        ? {
-          -readonly [K in keyof Pick<
-            TimestampOptions,
-            'createdAt' | 'updatedAt'
-          > as TimestampOptions[K] extends true
-            ? K
-            : TimestampOptions[K] extends `${infer TimestampValue}`
-              ? TimestampValue
-              : never]: NativeDate;
-        } & T
-        : T
+  type ResolveTimestamps<T, O> = O extends
+    | { methods: any }
+    | { statics: any }
+    | { virtuals: any }
+    | { timestamps?: false }
+    ? T
+    : // For some reason, TypeScript sets all the document properties to unknown
+      // if we use methods, statics, or virtuals. So avoid inferring timestamps
+      // if any of these are set for now. See gh-12807
+      O extends { timestamps: infer TimestampOptions }
+      ? TimestampOptions extends true
+        ? { createdAt: NativeDate; updatedAt: NativeDate } & T
+        : TimestampOptions extends SchemaTimestampsConfig
+          ? {
+              -readonly [K in keyof Pick<
+                TimestampOptions,
+                'createdAt' | 'updatedAt'
+              > as TimestampOptions[K] extends true
+                ? K
+                : TimestampOptions[K] extends `${infer TimestampValue}`
+                  ? TimestampValue
+                  : never]: NativeDate;
+            } & T
+          : T
       : T;
 }
 
-type IsPathDefaultUndefined<PathType> = PathType extends { default: undefined } ?
-  true :
-  PathType extends { default: (...args: any[]) => undefined } ?
-    true :
-    false;
+type IsPathDefaultUndefined<PathType> = PathType extends { default: undefined }
+  ? true
+  : PathType extends { default: (...args: any[]) => undefined }
+    ? true
+    : false;
 
 /**
  * @summary Checks if a document path is required or optional.
  * @param {P} P Document path.
  * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
  */
-type IsPathRequired<P, TypeKey extends string = DefaultTypeKey> =
-  P extends { required: true | [true, string | undefined] | { isRequired: true } } | ArrayConstructor | any[]
-    ? true
-    : P extends { required: boolean }
-      ? P extends { required: false }
+type IsPathRequired<P, TypeKey extends string = DefaultTypeKey> = P extends
+  | { required: true | [true, string | undefined] | { isRequired: true } }
+  | ArrayConstructor
+  | any[]
+  ? true
+  : P extends { required: boolean }
+    ? P extends { required: false }
+      ? false
+      : true
+    : P extends Record<TypeKey, ArrayConstructor | any[]>
+      ? IsPathDefaultUndefined<P> extends true
         ? false
         : true
-      : P extends (Record<TypeKey, ArrayConstructor | any[]>)
-        ? IsPathDefaultUndefined<P> extends true
-          ? false
-          : true
-        : P extends (Record<TypeKey, any>)
-          ? P extends { default: any }
-            ? IfEquals<P['default'], undefined, false, true>
-            : false
-          : false;
+      : P extends Record<TypeKey, any>
+        ? P extends { default: any }
+          ? IfEquals<P['default'], undefined, false, true>
+          : false
+        : false;
 
 /**
  * @summary Path base type defined by using TypeKey
  * @description It helps to check if a path is defined by TypeKey OR not.
  * @param {TypeKey} TypeKey A literal string refers to path type property key.
  */
-type PathWithTypePropertyBaseType<TypeKey extends string = DefaultTypeKey> = { [k in TypeKey]: any };
+type PathWithTypePropertyBaseType<TypeKey extends string = DefaultTypeKey> = {
+  [k in TypeKey]: any;
+};
 
 /**
  * @summary A Utility to obtain schema's required path keys.
@@ -137,7 +185,9 @@ type PathWithTypePropertyBaseType<TypeKey extends string = DefaultTypeKey> = { [
  * @returns required paths keys of document definition.
  */
 type RequiredPathKeys<T, TypeKey extends string = DefaultTypeKey> = {
-  [K in keyof T]: IsPathRequired<T[K], TypeKey> extends true ? IfEquals<T[K], any, never, K> : never;
+  [K in keyof T]: IsPathRequired<T[K], TypeKey> extends true
+    ? IfEquals<T[K], any, never, K>
+    : never;
 }[keyof T];
 
 /**
@@ -175,8 +225,7 @@ type OptionalPaths<T, TypeKey extends string = DefaultTypeKey> = Pick<
 /**
  * @summary Allows users to optionally choose their own type for a schema field for stronger typing.
  */
-type TypeHint<T> = T extends { __typehint: infer U } ? U: never;
-
+type TypeHint<T> = T extends { __typehint: infer U } ? U : never;
 
 /**
  * @summary Obtains schema Path type.
@@ -184,7 +233,10 @@ type TypeHint<T> = T extends { __typehint: infer U } ? U: never;
  * @param {PathValueType} PathValueType Document definition path type.
  * @param {TypeKey} TypeKey A generic refers to document definition.
  */
-type ObtainDocumentPathType<PathValueType, TypeKey extends string = DefaultTypeKey> = ResolvePathType<
+type ObtainDocumentPathType<
+  PathValueType,
+  TypeKey extends string = DefaultTypeKey,
+> = ResolvePathType<
   PathValueType extends PathWithTypePropertyBaseType<TypeKey>
     ? PathValueType[TypeKey] extends PathWithTypePropertyBaseType<TypeKey>
       ? PathValueType
@@ -195,39 +247,44 @@ type ObtainDocumentPathType<PathValueType, TypeKey extends string = DefaultTypeK
       ? {}
       : Omit<PathValueType, TypeKey>
     : {},
-TypeKey,
-TypeHint<PathValueType>
+  TypeKey,
+  TypeHint<PathValueType>
 >;
 
 /**
  * @param {T} T A generic refers to string path enums.
  * @returns Path enum values type as literal strings or string.
  */
-type PathEnumOrString<T extends SchemaTypeOptions<string>['enum']> = T extends ReadonlyArray<infer E> ? E : T extends { values: any } ? PathEnumOrString<T['values']> : string;
+type PathEnumOrString<T extends SchemaTypeOptions<string>['enum']> =
+  T extends ReadonlyArray<infer E>
+    ? E
+    : T extends { values: any }
+      ? PathEnumOrString<T['values']>
+      : string;
 
-type IsSchemaTypeFromBuiltinClass<T> = T extends (typeof String)
+type IsSchemaTypeFromBuiltinClass<T> = T extends typeof String
   ? true
-  : T extends (typeof Number)
+  : T extends typeof Number
     ? true
-    : T extends (typeof Boolean)
+    : T extends typeof Boolean
       ? true
-      : T extends (typeof Buffer)
+      : T extends typeof Buffer
         ? true
-        : T extends (typeof Schema.Types.ObjectId)
+        : T extends typeof Schema.Types.ObjectId
           ? true
-          : T extends (typeof Schema.Types.UUID)
+          : T extends typeof Schema.Types.UUID
             ? true
-            : T extends (typeof Schema.Types.Decimal128)
+            : T extends typeof Schema.Types.Decimal128
               ? true
-              : T extends (typeof Schema.Types.String)
+              : T extends typeof Schema.Types.String
                 ? true
-                : T extends (typeof Schema.Types.Number)
+                : T extends typeof Schema.Types.Number
                   ? true
-                  : T extends (typeof Schema.Types.Date)
+                  : T extends typeof Schema.Types.Date
                     ? true
-                    : T extends (typeof Schema.Types.Boolean)
+                    : T extends typeof Schema.Types.Boolean
                       ? true
-                      : T extends (typeof Schema.Types.Buffer)
+                      : T extends typeof Schema.Types.Buffer
                         ? true
                         : T extends Types.ObjectId
                           ? true
@@ -237,9 +294,14 @@ type IsSchemaTypeFromBuiltinClass<T> = T extends (typeof String)
                               ? true
                               : T extends NativeDate
                                 ? true
-                                : T extends (typeof Schema.Types.Mixed)
+                                : T extends typeof Schema.Types.Mixed
                                   ? true
-                                  : IfEquals<T, Schema.Types.ObjectId, true, false>;
+                                  : IfEquals<
+                                      T,
+                                      Schema.Types.ObjectId,
+                                      true,
+                                      false
+                                    >;
 
 /**
  * @summary Resolve path type by returning the corresponding type.
@@ -248,72 +310,193 @@ type IsSchemaTypeFromBuiltinClass<T> = T extends (typeof String)
  * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
  * @returns Number, "Number" or "number" will be resolved to number type.
  */
-type ResolvePathType<PathValueType, Options extends SchemaTypeOptions<PathValueType> = {}, TypeKey extends string = DefaultSchemaOptions['typeKey'], TypeHint = never> =
-  IfEquals<TypeHint, never,
-    PathValueType extends Schema ? InferSchemaType<PathValueType> :
-      PathValueType extends (infer Item)[] ?
-        IfEquals<Item, never, any[], Item extends Schema ?
-          // If Item is a schema, infer its type.
-          Types.DocumentArray<InferSchemaType<Item>> :
-          Item extends Record<TypeKey, any> ?
-            Item[TypeKey] extends Function | String ?
-              // If Item has a type key that's a string or a callable, it must be a scalar,
-              // so we can directly obtain its path type.
-              ObtainDocumentPathType<Item, TypeKey>[] :
-              // If the type key isn't callable, then this is an array of objects, in which case
-              // we need to call ObtainDocumentType to correctly infer its type.
-              Types.DocumentArray<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
-            IsSchemaTypeFromBuiltinClass<Item> extends true ?
-              ObtainDocumentPathType<Item, TypeKey>[] :
-              IsItRecordAndNotAny<Item> extends true ?
-                Item extends Record<string, never> ?
-                  ObtainDocumentPathType<Item, TypeKey>[] :
-                  Types.DocumentArray<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
-                ObtainDocumentPathType<Item, TypeKey>[]
-        >:
-        PathValueType extends ReadonlyArray<infer Item> ?
-          IfEquals<Item, never, any[], Item extends Schema ?
-            Types.DocumentArray<InferSchemaType<Item>> :
-            Item extends Record<TypeKey, any> ?
-              Item[TypeKey] extends Function | String ?
-                ObtainDocumentPathType<Item, TypeKey>[] :
-                ObtainDocumentType<Item, any, { typeKey: TypeKey }>[]:
-              IsSchemaTypeFromBuiltinClass<Item> extends true ?
-                ObtainDocumentPathType<Item, TypeKey>[] :
-                IsItRecordAndNotAny<Item> extends true ?
-                  Item extends Record<string, never> ?
-                    ObtainDocumentPathType<Item, TypeKey>[] :
-                    Types.DocumentArray<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
+type ResolvePathType<
+  PathValueType,
+  Options extends SchemaTypeOptions<PathValueType> = {},
+  TypeKey extends string = DefaultSchemaOptions['typeKey'],
+  TypeHint = never,
+> = IfEquals<
+  TypeHint,
+  never,
+  PathValueType extends Schema
+    ? InferSchemaType<PathValueType>
+    : PathValueType extends (infer Item)[]
+      ? IfEquals<
+          Item,
+          never,
+          any[],
+          Item extends Schema
+            ? // If Item is a schema, infer its type.
+              Types.DocumentArray<InferSchemaType<Item>>
+            : Item extends Record<TypeKey, any>
+              ? Item[TypeKey] extends Function | String
+                ? // If Item has a type key that's a string or a callable, it must be a scalar,
+                  // so we can directly obtain its path type.
                   ObtainDocumentPathType<Item, TypeKey>[]
-          >:
-          PathValueType extends StringSchemaDefinition ? PathEnumOrString<Options['enum']> :
-            IfEquals<PathValueType, Schema.Types.String> extends true ? PathEnumOrString<Options['enum']> :
-              IfEquals<PathValueType, String> extends true ? PathEnumOrString<Options['enum']> :
-                PathValueType extends NumberSchemaDefinition ? Options['enum'] extends ReadonlyArray<any> ? Options['enum'][number] : number :
-                  IfEquals<PathValueType, Schema.Types.Number> extends true ? number :
-                    PathValueType extends DateSchemaDefinition ? NativeDate :
-                      IfEquals<PathValueType, Schema.Types.Date> extends true ? NativeDate :
-                        PathValueType extends typeof Buffer | 'buffer' | 'Buffer' | typeof Schema.Types.Buffer ? Buffer :
-                          PathValueType extends BooleanSchemaDefinition ? boolean :
-                            IfEquals<PathValueType, Schema.Types.Boolean> extends true ? boolean :
-                              PathValueType extends ObjectIdSchemaDefinition ? Types.ObjectId :
-                                IfEquals<PathValueType, Types.ObjectId> extends true ? Types.ObjectId :
-                                  IfEquals<PathValueType, Schema.Types.ObjectId> extends true ? Types.ObjectId :
-                                    PathValueType extends 'decimal128' | 'Decimal128' | typeof Schema.Types.Decimal128 ? Types.Decimal128 :
-                                      IfEquals<PathValueType, Schema.Types.Decimal128> extends true ? Types.Decimal128 :
-                                        IfEquals<PathValueType, Types.Decimal128> extends true ? Types.Decimal128 :
-                                          IfEquals<PathValueType, Schema.Types.BigInt> extends true ? bigint :
-                                            IfEquals<PathValueType, BigInt> extends true ? bigint :
-                                              PathValueType extends 'bigint' | 'BigInt' | typeof Schema.Types.BigInt | typeof BigInt ? bigint :
-                                                PathValueType extends 'uuid' | 'UUID' | typeof Schema.Types.UUID ? Buffer :
-                                                  IfEquals<PathValueType, Schema.Types.UUID> extends true ? Buffer :
-                                                    PathValueType extends MapConstructor | 'Map' ? Map<string, ResolvePathType<Options['of']>> :
-                                                      IfEquals<PathValueType, typeof Schema.Types.Map> extends true ? Map<string, ResolvePathType<Options['of']>> :
-                                                        PathValueType extends ArrayConstructor ? any[] :
-                                                          PathValueType extends typeof Schema.Types.Mixed ? any:
-                                                            IfEquals<PathValueType, ObjectConstructor> extends true ? any:
-                                                              IfEquals<PathValueType, {}> extends true ? any:
-                                                                PathValueType extends typeof SchemaType ? PathValueType['prototype'] :
-                                                                  PathValueType extends Record<string, any> ? ObtainDocumentType<PathValueType, any, { typeKey: TypeKey }> :
-                                                                    unknown,
-    TypeHint>;
+                : // If the type key isn't callable, then this is an array of objects, in which case
+                  // we need to call ObtainDocumentType to correctly infer its type.
+                  Types.DocumentArray<
+                    ObtainDocumentType<Item, any, { typeKey: TypeKey }>
+                  >
+              : IsSchemaTypeFromBuiltinClass<Item> extends true
+                ? ObtainDocumentPathType<Item, TypeKey>[]
+                : IsItRecordAndNotAny<Item> extends true
+                  ? Item extends Record<string, never>
+                    ? ObtainDocumentPathType<Item, TypeKey>[]
+                    : Types.DocumentArray<
+                        ObtainDocumentType<Item, any, { typeKey: TypeKey }>
+                      >
+                  : ObtainDocumentPathType<Item, TypeKey>[]
+        >
+      : PathValueType extends ReadonlyArray<infer Item>
+        ? IfEquals<
+            Item,
+            never,
+            any[],
+            Item extends Schema
+              ? Types.DocumentArray<InferSchemaType<Item>>
+              : Item extends Record<TypeKey, any>
+                ? Item[TypeKey] extends Function | String
+                  ? ObtainDocumentPathType<Item, TypeKey>[]
+                  : ObtainDocumentType<Item, any, { typeKey: TypeKey }>[]
+                : IsSchemaTypeFromBuiltinClass<Item> extends true
+                  ? ObtainDocumentPathType<Item, TypeKey>[]
+                  : IsItRecordAndNotAny<Item> extends true
+                    ? Item extends Record<string, never>
+                      ? ObtainDocumentPathType<Item, TypeKey>[]
+                      : Types.DocumentArray<
+                          ObtainDocumentType<Item, any, { typeKey: TypeKey }>
+                        >
+                    : ObtainDocumentPathType<Item, TypeKey>[]
+          >
+        : PathValueType extends StringSchemaDefinition
+          ? PathEnumOrString<Options['enum']>
+          : IfEquals<PathValueType, Schema.Types.String> extends true
+            ? PathEnumOrString<Options['enum']>
+            : IfEquals<PathValueType, String> extends true
+              ? PathEnumOrString<Options['enum']>
+              : PathValueType extends NumberSchemaDefinition
+                ? Options['enum'] extends ReadonlyArray<any>
+                  ? Options['enum'][number]
+                  : number
+                : IfEquals<PathValueType, Schema.Types.Number> extends true
+                  ? number
+                  : PathValueType extends DateSchemaDefinition
+                    ? NativeDate
+                    : IfEquals<PathValueType, Schema.Types.Date> extends true
+                      ? NativeDate
+                      : PathValueType extends
+                            | typeof Buffer
+                            | 'buffer'
+                            | 'Buffer'
+                            | typeof Schema.Types.Buffer
+                        ? Buffer
+                        : PathValueType extends BooleanSchemaDefinition
+                          ? boolean
+                          : IfEquals<
+                                PathValueType,
+                                Schema.Types.Boolean
+                              > extends true
+                            ? boolean
+                            : PathValueType extends ObjectIdSchemaDefinition
+                              ? Types.ObjectId
+                              : IfEquals<
+                                    PathValueType,
+                                    Types.ObjectId
+                                  > extends true
+                                ? Types.ObjectId
+                                : IfEquals<
+                                      PathValueType,
+                                      Schema.Types.ObjectId
+                                    > extends true
+                                  ? Types.ObjectId
+                                  : PathValueType extends
+                                        | 'decimal128'
+                                        | 'Decimal128'
+                                        | typeof Schema.Types.Decimal128
+                                    ? Types.Decimal128
+                                    : IfEquals<
+                                          PathValueType,
+                                          Schema.Types.Decimal128
+                                        > extends true
+                                      ? Types.Decimal128
+                                      : IfEquals<
+                                            PathValueType,
+                                            Types.Decimal128
+                                          > extends true
+                                        ? Types.Decimal128
+                                        : IfEquals<
+                                              PathValueType,
+                                              Schema.Types.BigInt
+                                            > extends true
+                                          ? bigint
+                                          : IfEquals<
+                                                PathValueType,
+                                                BigInt
+                                              > extends true
+                                            ? bigint
+                                            : PathValueType extends
+                                                  | 'bigint'
+                                                  | 'BigInt'
+                                                  | typeof Schema.Types.BigInt
+                                                  | typeof BigInt
+                                              ? bigint
+                                              : PathValueType extends
+                                                    | 'uuid'
+                                                    | 'UUID'
+                                                    | typeof Schema.Types.UUID
+                                                ? Buffer
+                                                : IfEquals<
+                                                      PathValueType,
+                                                      Schema.Types.UUID
+                                                    > extends true
+                                                  ? Buffer
+                                                  : PathValueType extends
+                                                        | MapConstructor
+                                                        | 'Map'
+                                                    ? Map<
+                                                        string,
+                                                        ResolvePathType<
+                                                          Options['of']
+                                                        >
+                                                      >
+                                                    : IfEquals<
+                                                          PathValueType,
+                                                          typeof Schema.Types.Map
+                                                        > extends true
+                                                      ? Map<
+                                                          string,
+                                                          ResolvePathType<
+                                                            Options['of']
+                                                          >
+                                                        >
+                                                      : PathValueType extends ArrayConstructor
+                                                        ? any[]
+                                                        : PathValueType extends typeof Schema.Types.Mixed
+                                                          ? any
+                                                          : IfEquals<
+                                                                PathValueType,
+                                                                ObjectConstructor
+                                                              > extends true
+                                                            ? any
+                                                            : IfEquals<
+                                                                  PathValueType,
+                                                                  {}
+                                                                > extends true
+                                                              ? any
+                                                              : PathValueType extends typeof SchemaType
+                                                                ? PathValueType['prototype']
+                                                                : PathValueType extends Record<
+                                                                      string,
+                                                                      any
+                                                                    >
+                                                                  ? ObtainDocumentType<
+                                                                      PathValueType,
+                                                                      any,
+                                                                      {
+                                                                        typeKey: TypeKey;
+                                                                      }
+                                                                    >
+                                                                  : unknown,
+  TypeHint
+>;
diff --git a/types/middlewares.d.ts b/types/middlewares.d.ts
index 8d380ed69d127c5117809537c88e29c7e6f31a18..cf0971d55c5f5985c0108743f8725dc65822c9ad 100644
--- a/types/middlewares.d.ts
+++ b/types/middlewares.d.ts
@@ -1,35 +1,59 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import Kareem = require('kareem');
 
   type MongooseQueryAndDocumentMiddleware = 'updateOne' | 'deleteOne';
 
   type MongooseDistinctDocumentMiddleware = 'save' | 'init' | 'validate';
-  type MongooseDocumentMiddleware = MongooseDistinctDocumentMiddleware | MongooseQueryAndDocumentMiddleware;
+  type MongooseDocumentMiddleware =
+    | MongooseDistinctDocumentMiddleware
+    | MongooseQueryAndDocumentMiddleware;
 
-  type MongooseRawResultQueryMiddleware = 'findOneAndUpdate' | 'findOneAndReplace' | 'findOneAndDelete';
-  type MongooseDistinctQueryMiddleware = 'estimatedDocumentCount' | 'countDocuments' | 'deleteMany' | 'distinct' | 'find' | 'findOne' | 'findOneAndDelete' | 'findOneAndReplace' | 'findOneAndUpdate' | 'replaceOne' | 'updateMany';
+  type MongooseRawResultQueryMiddleware =
+    | 'findOneAndUpdate'
+    | 'findOneAndReplace'
+    | 'findOneAndDelete';
+  type MongooseDistinctQueryMiddleware =
+    | 'estimatedDocumentCount'
+    | 'countDocuments'
+    | 'deleteMany'
+    | 'distinct'
+    | 'find'
+    | 'findOne'
+    | 'findOneAndDelete'
+    | 'findOneAndReplace'
+    | 'findOneAndUpdate'
+    | 'replaceOne'
+    | 'updateMany';
 
-  type MongooseDefaultQueryMiddleware = MongooseDistinctQueryMiddleware | 'updateOne' | 'deleteOne';
-  type MongooseQueryMiddleware = MongooseDistinctQueryMiddleware | MongooseQueryAndDocumentMiddleware;
+  type MongooseDefaultQueryMiddleware =
+    | MongooseDistinctQueryMiddleware
+    | 'updateOne'
+    | 'deleteOne';
+  type MongooseQueryMiddleware =
+    | MongooseDistinctQueryMiddleware
+    | MongooseQueryAndDocumentMiddleware;
 
-  type MongooseQueryOrDocumentMiddleware = MongooseDistinctQueryMiddleware|MongooseDistinctDocumentMiddleware|MongooseQueryAndDocumentMiddleware;
+  type MongooseQueryOrDocumentMiddleware =
+    | MongooseDistinctQueryMiddleware
+    | MongooseDistinctDocumentMiddleware
+    | MongooseQueryAndDocumentMiddleware;
 
   type MiddlewareOptions = {
     /**
-      * Enable this Hook for the Document Methods
-      * @default true
-      */
-    document?: boolean,
+     * Enable this Hook for the Document Methods
+     * @default true
+     */
+    document?: boolean;
     /**
-      * Enable this Hook for the Query Methods
-      * @default true
-      */
-    query?: boolean,
+     * Enable this Hook for the Query Methods
+     * @default true
+     */
+    query?: boolean;
     /**
-      * Explicitly set this function to be a Error handler instead of based on how many arguments are used
-      * @default false
-      */
-    errorHandler?: boolean
+     * Explicitly set this function to be a Error handler instead of based on how many arguments are used
+     * @default false
+     */
+    errorHandler?: boolean;
   };
   type SchemaPreOptions = MiddlewareOptions;
   type SchemaPostOptions = MiddlewareOptions;
@@ -37,14 +61,28 @@ declare module 'mongoose' {
   type PreMiddlewareFunction<ThisType = any> = (
     this: ThisType,
     next: CallbackWithoutResultAndOptionalError,
-    opts?: Record<string, any>
+    opts?: Record<string, any>,
   ) => void | Promise<void> | Kareem.SkipWrappedFunction;
   type PreSaveMiddlewareFunction<ThisType = any> = (
     this: ThisType,
     next: CallbackWithoutResultAndOptionalError,
-    opts: SaveOptions
+    opts: SaveOptions,
   ) => void | Promise<void> | Kareem.SkipWrappedFunction;
-  type PostMiddlewareFunction<ThisType = any, ResType = any> = (this: ThisType, res: ResType, next: CallbackWithoutResultAndOptionalError) => void | Promise<void> | Kareem.OverwriteMiddlewareResult;
-  type ErrorHandlingMiddlewareFunction<ThisType = any, ResType = any> = (this: ThisType, err: NativeError, res: ResType, next: CallbackWithoutResultAndOptionalError) => void;
-  type ErrorHandlingMiddlewareWithOption<ThisType = any, ResType = any> = (this: ThisType, err: NativeError, res: ResType | null, next: CallbackWithoutResultAndOptionalError) => void | Promise<void> | Kareem.OverwriteMiddlewareResult;
+  type PostMiddlewareFunction<ThisType = any, ResType = any> = (
+    this: ThisType,
+    res: ResType,
+    next: CallbackWithoutResultAndOptionalError,
+  ) => void | Promise<void> | Kareem.OverwriteMiddlewareResult;
+  type ErrorHandlingMiddlewareFunction<ThisType = any, ResType = any> = (
+    this: ThisType,
+    err: NativeError,
+    res: ResType,
+    next: CallbackWithoutResultAndOptionalError,
+  ) => void;
+  type ErrorHandlingMiddlewareWithOption<ThisType = any, ResType = any> = (
+    this: ThisType,
+    err: NativeError,
+    res: ResType | null,
+    next: CallbackWithoutResultAndOptionalError,
+  ) => void | Promise<void> | Kareem.OverwriteMiddlewareResult;
 }
diff --git a/types/models.d.ts b/types/models.d.ts
index 5a5ced609445e3e6a3bcc5114e8e55d5c6c6a380..64f56f142ba513d2b7ab5e2e62ba2702f352ae0a 100644
--- a/types/models.d.ts
+++ b/types/models.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   export interface DiscriminatorOptions {
@@ -14,12 +14,12 @@ declare module 'mongoose' {
     discriminator<D>(
       name: string | number,
       schema: Schema,
-      value?: string | number | ObjectId | DiscriminatorOptions
+      value?: string | number | ObjectId | DiscriminatorOptions,
     ): Model<D>;
     discriminator<T, U>(
       name: string | number,
       schema: Schema<T, U>,
-      value?: string | number | ObjectId | DiscriminatorOptions
+      value?: string | number | ObjectId | DiscriminatorOptions,
     ): U;
   }
 
@@ -52,9 +52,7 @@ declare module 'mongoose' {
     hydratedPopulatedDocs?: boolean;
   }
 
-  interface InsertManyOptions extends
-    PopulateOption,
-    SessionOption {
+  interface InsertManyOptions extends PopulateOption, SessionOption {
     limit?: number;
     // @deprecated, use includeResultMetadata instead
     rawResult?: boolean;
@@ -65,7 +63,9 @@ declare module 'mongoose' {
   }
 
   interface InsertManyResult<T> extends mongodb.InsertManyResult<T> {
-    mongoose?: { validationErrors?: Array<Error.CastError | Error.ValidatorError> };
+    mongoose?: {
+      validationErrors?: Array<Error.CastError | Error.ValidatorError>;
+    };
   }
 
   type UpdateWriteOpResult = mongodb.UpdateResult;
@@ -144,8 +144,7 @@ declare module 'mongoose' {
    */
   type pathsToValidate = PathsToValidate;
 
-  interface SaveOptions extends
-    SessionOption {
+  interface SaveOptions extends SessionOption {
     checkKeys?: boolean;
     j?: boolean;
     safe?: boolean | WriteConcern;
@@ -161,23 +160,31 @@ declare module 'mongoose' {
     aggregateErrors?: boolean;
   }
 
-  interface RemoveOptions extends SessionOption, Omit<mongodb.DeleteOptions, 'session'> {}
+  interface RemoveOptions
+    extends SessionOption,
+      Omit<mongodb.DeleteOptions, 'session'> {}
 
   const Model: Model<any>;
 
-  export type AnyBulkWriteOperation<TSchema = AnyObject> = {
-    insertOne: InsertOneModel<TSchema>;
-  } | {
-    replaceOne: ReplaceOneModel<TSchema>;
-  } | {
-    updateOne: UpdateOneModel<TSchema>;
-  } | {
-    updateMany: UpdateManyModel<TSchema>;
-  } | {
-    deleteOne: DeleteOneModel<TSchema>;
-  } | {
-    deleteMany: DeleteManyModel<TSchema>;
-  };
+  export type AnyBulkWriteOperation<TSchema = AnyObject> =
+    | {
+        insertOne: InsertOneModel<TSchema>;
+      }
+    | {
+        replaceOne: ReplaceOneModel<TSchema>;
+      }
+    | {
+        updateOne: UpdateOneModel<TSchema>;
+      }
+    | {
+        updateMany: UpdateManyModel<TSchema>;
+      }
+    | {
+        deleteOne: DeleteOneModel<TSchema>;
+      }
+    | {
+        deleteMany: DeleteManyModel<TSchema>;
+      };
 
   export interface InsertOneModel<TSchema> {
     document: mongodb.OptionalId<TSchema>;
@@ -262,15 +269,26 @@ declare module 'mongoose' {
     TQueryHelpers = {},
     TInstanceMethods = {},
     TVirtuals = {},
-    THydratedDocumentType = HydratedDocument<TRawDocType, TVirtuals & TInstanceMethods, TQueryHelpers>,
-    TSchema = any> extends
-    NodeJS.EventEmitter,
-    AcceptsDiscriminator,
-    IndexManager,
-    SessionStarter {
-    new <DocType = Partial<TRawDocType>>(doc?: DocType, fields?: any | null, options?: boolean | AnyObject): THydratedDocumentType;
-
-    aggregate<R = any>(pipeline?: PipelineStage[], options?: AggregateOptions): Aggregate<Array<R>>;
+    THydratedDocumentType = HydratedDocument<
+      TRawDocType,
+      TVirtuals & TInstanceMethods,
+      TQueryHelpers
+    >,
+    TSchema = any,
+  > extends NodeJS.EventEmitter,
+      AcceptsDiscriminator,
+      IndexManager,
+      SessionStarter {
+    new <DocType = Partial<TRawDocType>>(
+      doc?: DocType,
+      fields?: any | null,
+      options?: boolean | AnyObject,
+    ): THydratedDocumentType;
+
+    aggregate<R = any>(
+      pipeline?: PipelineStage[],
+      options?: AggregateOptions,
+    ): Aggregate<Array<R>>;
     aggregate<R = any>(pipeline: PipelineStage[]): Aggregate<Array<R>>;
 
     /** Base Mongoose instance the model uses. */
@@ -283,7 +301,10 @@ declare module 'mongoose' {
     baseModelName: string | undefined;
 
     /* Cast the given POJO to the model's schema */
-    castObject(obj: AnyObject, options?: { ignoreCastErrors?: boolean }): TRawDocType;
+    castObject(
+      obj: AnyObject,
+      options?: { ignoreCastErrors?: boolean },
+    ): TRawDocType;
 
     /* Apply defaults to the given document or POJO. */
     applyDefaults(obj: AnyObject): AnyObject;
@@ -295,7 +316,10 @@ declare module 'mongoose' {
     /**
      * Apply this model's timestamps to a given POJO, including subdocument timestamps
      */
-    applyTimestamps(obj: AnyObject, options?: { isUpdate?: boolean, currentTime?: () => Date }): AnyObject;
+    applyTimestamps(
+      obj: AnyObject,
+      options?: { isUpdate?: boolean; currentTime?: () => Date },
+    ): AnyObject;
 
     /**
      * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,
@@ -305,12 +329,30 @@ declare module 'mongoose' {
      * round trip to the MongoDB server.
      */
     bulkWrite<DocContents = TRawDocType>(
-      writes: Array<AnyBulkWriteOperation<DocContents extends Document ? any : (DocContents extends {} ? DocContents : any)>>,
-      options: MongooseBulkWriteOptions & { ordered: false }
-    ): Promise<mongodb.BulkWriteResult & { mongoose?: { validationErrors: Error[] } }>;
+      writes: Array<
+        AnyBulkWriteOperation<
+          DocContents extends Document
+            ? any
+            : DocContents extends {}
+              ? DocContents
+              : any
+        >
+      >,
+      options: MongooseBulkWriteOptions & { ordered: false },
+    ): Promise<
+      mongodb.BulkWriteResult & { mongoose?: { validationErrors: Error[] } }
+    >;
     bulkWrite<DocContents = TRawDocType>(
-      writes: Array<AnyBulkWriteOperation<DocContents extends Document ? any : (DocContents extends {} ? DocContents : any)>>,
-      options?: MongooseBulkWriteOptions
+      writes: Array<
+        AnyBulkWriteOperation<
+          DocContents extends Document
+            ? any
+            : DocContents extends {}
+              ? DocContents
+              : any
+        >
+      >,
+      options?: MongooseBulkWriteOptions,
     ): Promise<mongodb.BulkWriteResult>;
 
     /**
@@ -318,7 +360,10 @@ declare module 'mongoose' {
      * sending multiple `save()` calls because with `bulkSave()` there is only one
      * network round trip to the MongoDB server.
      */
-    bulkSave(documents: Array<Document>, options?: MongooseBulkSaveOptions): Promise<mongodb.BulkWriteResult>;
+    bulkSave(
+      documents: Array<Document>,
+      options?: MongooseBulkSaveOptions,
+    ): Promise<mongodb.BulkWriteResult>;
 
     /** Collection the model uses. */
     collection: Collection;
@@ -326,7 +371,9 @@ declare module 'mongoose' {
     /** Creates a `countDocuments` query: counts the number of documents that match `filter`. */
     countDocuments(
       filter?: RootFilterQuery<TRawDocType>,
-      options?: (mongodb.CountOptions & MongooseBaseQueryOptions<TRawDocType>) | null
+      options?:
+        | (mongodb.CountOptions & MongooseBaseQueryOptions<TRawDocType>)
+        | null,
     ): QueryWithHelpers<
       number,
       THydratedDocumentType,
@@ -337,17 +384,30 @@ declare module 'mongoose' {
     >;
 
     /** Creates a new document or documents */
-    create<DocContents = AnyKeys<TRawDocType>>(docs: Array<TRawDocType | DocContents>, options: CreateOptions & { aggregateErrors: true }): Promise<(THydratedDocumentType | Error)[]>;
-    create<DocContents = AnyKeys<TRawDocType>>(docs: Array<TRawDocType | DocContents>, options?: CreateOptions): Promise<THydratedDocumentType[]>;
-    create<DocContents = AnyKeys<TRawDocType>>(doc: DocContents | TRawDocType): Promise<THydratedDocumentType>;
-    create<DocContents = AnyKeys<TRawDocType>>(...docs: Array<TRawDocType | DocContents>): Promise<THydratedDocumentType[]>;
+    create<DocContents = AnyKeys<TRawDocType>>(
+      docs: Array<TRawDocType | DocContents>,
+      options: CreateOptions & { aggregateErrors: true },
+    ): Promise<(THydratedDocumentType | Error)[]>;
+    create<DocContents = AnyKeys<TRawDocType>>(
+      docs: Array<TRawDocType | DocContents>,
+      options?: CreateOptions,
+    ): Promise<THydratedDocumentType[]>;
+    create<DocContents = AnyKeys<TRawDocType>>(
+      doc: DocContents | TRawDocType,
+    ): Promise<THydratedDocumentType>;
+    create<DocContents = AnyKeys<TRawDocType>>(
+      ...docs: Array<TRawDocType | DocContents>
+    ): Promise<THydratedDocumentType[]>;
 
     /**
      * Create the collection for this model. By default, if no indexes are specified,
      * mongoose will not create the collection for the model until any documents are
      * created. Use this method to create the collection explicitly.
      */
-    createCollection<T extends mongodb.Document>(options?: mongodb.CreateCollectionOptions & Pick<SchemaOptions, 'expires'>): Promise<mongodb.Collection<T>>;
+    createCollection<T extends mongodb.Document>(
+      options?: mongodb.CreateCollectionOptions &
+        Pick<SchemaOptions, 'expires'>,
+    ): Promise<mongodb.Collection<T>>;
 
     /**
      * Create an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).
@@ -365,7 +425,9 @@ declare module 'mongoose' {
      */
     deleteMany(
       filter?: RootFilterQuery<TRawDocType>,
-      options?: (mongodb.DeleteOptions & MongooseBaseQueryOptions<TRawDocType>) | null
+      options?:
+        | (mongodb.DeleteOptions & MongooseBaseQueryOptions<TRawDocType>)
+        | null,
     ): QueryWithHelpers<
       mongodb.DeleteResult,
       THydratedDocumentType,
@@ -375,7 +437,7 @@ declare module 'mongoose' {
       TInstanceMethods
     >;
     deleteMany(
-      filter: RootFilterQuery<TRawDocType>
+      filter: RootFilterQuery<TRawDocType>,
     ): QueryWithHelpers<
       mongodb.DeleteResult,
       THydratedDocumentType,
@@ -392,7 +454,9 @@ declare module 'mongoose' {
      */
     deleteOne(
       filter?: RootFilterQuery<TRawDocType>,
-      options?: (mongodb.DeleteOptions & MongooseBaseQueryOptions<TRawDocType>) | null
+      options?:
+        | (mongodb.DeleteOptions & MongooseBaseQueryOptions<TRawDocType>)
+        | null,
     ): QueryWithHelpers<
       mongodb.DeleteResult,
       THydratedDocumentType,
@@ -402,7 +466,7 @@ declare module 'mongoose' {
       TInstanceMethods
     >;
     deleteOne(
-      filter: RootFilterQuery<TRawDocType>
+      filter: RootFilterQuery<TRawDocType>,
     ): QueryWithHelpers<
       mongodb.DeleteResult,
       THydratedDocumentType,
@@ -432,7 +496,7 @@ declare module 'mongoose' {
     findById<ResultDoc = THydratedDocumentType>(
       id: any,
       projection: ProjectionType<TRawDocType> | null | undefined,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType, 'findOne'> | null,
       ResultDoc,
@@ -444,18 +508,32 @@ declare module 'mongoose' {
     findById<ResultDoc = THydratedDocumentType>(
       id: any,
       projection?: ProjectionType<TRawDocType> | null,
-      options?: QueryOptions<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOne', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
     findById<ResultDoc = THydratedDocumentType>(
       id: any,
-      projection?: ProjectionType<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOne', TInstanceMethods>;
+      projection?: ProjectionType<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
 
     /** Finds one document. */
     findOne<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       projection: ProjectionType<TRawDocType> | null | undefined,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType, 'findOne'> | null,
       ResultDoc,
@@ -467,21 +545,46 @@ declare module 'mongoose' {
     findOne<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType>,
       projection?: ProjectionType<TRawDocType> | null,
-      options?: QueryOptions<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOne', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
     findOne<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType>,
-      projection?: ProjectionType<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOne', TInstanceMethods>;
+      projection?: ProjectionType<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
     findOne<ResultDoc = THydratedDocumentType>(
-      filter?: RootFilterQuery<TRawDocType>
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOne', TInstanceMethods>;
+      filter?: RootFilterQuery<TRawDocType>,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
 
     /**
      * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.
      * The document returned has no paths marked as modified initially.
      */
-    hydrate(obj: any, projection?: AnyObject, options?: HydrateOptions): THydratedDocumentType;
+    hydrate(
+      obj: any,
+      projection?: AnyObject,
+      options?: HydrateOptions,
+    ): THydratedDocumentType;
 
     /**
      * This function is responsible for building [indexes](https://www.mongodb.com/docs/manual/indexes/),
@@ -494,84 +597,86 @@ declare module 'mongoose' {
     init(): Promise<THydratedDocumentType>;
 
     /** Inserts one or more new documents as a single `insertMany` call to the MongoDB server. */
-    insertMany(
-      docs: Array<TRawDocType>
-    ): Promise<Array<THydratedDocumentType>>;
+    insertMany(docs: Array<TRawDocType>): Promise<Array<THydratedDocumentType>>;
     insertMany(
       docs: Array<TRawDocType>,
-      options: InsertManyOptions & { lean: true; }
+      options: InsertManyOptions & { lean: true },
     ): Promise<Array<Require_id<TRawDocType>>>;
     insertMany(
       doc: Array<TRawDocType>,
-      options: InsertManyOptions & { ordered: false; rawResult: true; }
-    ): Promise<mongodb.InsertManyResult<Require_id<TRawDocType>> & {
-      mongoose: {
-        validationErrors: (CastError | Error.ValidatorError)[];
-        results: Array<
-          Error |
-          Object |
-          THydratedDocumentType
-        >
+      options: InsertManyOptions & { ordered: false; rawResult: true },
+    ): Promise<
+      mongodb.InsertManyResult<Require_id<TRawDocType>> & {
+        mongoose: {
+          validationErrors: (CastError | Error.ValidatorError)[];
+          results: Array<Error | Object | THydratedDocumentType>;
+        };
       }
-    }>;
+    >;
     insertMany(
       docs: Array<TRawDocType>,
-      options: InsertManyOptions & { lean: true, rawResult: true; }
+      options: InsertManyOptions & { lean: true; rawResult: true },
     ): Promise<mongodb.InsertManyResult<Require_id<TRawDocType>>>;
     insertMany(
       docs: Array<TRawDocType>,
-      options: InsertManyOptions & { rawResult: true; }
+      options: InsertManyOptions & { rawResult: true },
     ): Promise<mongodb.InsertManyResult<Require_id<THydratedDocumentType>>>;
     insertMany(
       doc: Array<TRawDocType>,
-      options: InsertManyOptions
+      options: InsertManyOptions,
     ): Promise<Array<THydratedDocumentType>>;
     insertMany<DocContents = TRawDocType>(
       docs: Array<DocContents | TRawDocType>,
-      options: InsertManyOptions & { lean: true; }
+      options: InsertManyOptions & { lean: true },
     ): Promise<Array<Require_id<DocContents>>>;
     insertMany<DocContents = TRawDocType>(
       docs: DocContents | TRawDocType,
-      options: InsertManyOptions & { lean: true; }
+      options: InsertManyOptions & { lean: true },
     ): Promise<Array<Require_id<DocContents>>>;
     insertMany<DocContents = TRawDocType>(
       doc: DocContents | TRawDocType,
-      options: InsertManyOptions & { ordered: false; rawResult: true; }
-    ): Promise<mongodb.InsertManyResult<Require_id<DocContents>> & {
-      mongoose: {
-        validationErrors: (CastError | Error.ValidatorError)[];
-        results: Array<
-          Error |
-          Object |
-          MergeType<THydratedDocumentType, DocContents>
-        >
+      options: InsertManyOptions & { ordered: false; rawResult: true },
+    ): Promise<
+      mongodb.InsertManyResult<Require_id<DocContents>> & {
+        mongoose: {
+          validationErrors: (CastError | Error.ValidatorError)[];
+          results: Array<
+            Error | Object | MergeType<THydratedDocumentType, DocContents>
+          >;
+        };
       }
-    }>;
+    >;
     insertMany<DocContents = TRawDocType>(
       docs: Array<DocContents | TRawDocType>,
-      options: InsertManyOptions & { rawResult: true; }
+      options: InsertManyOptions & { rawResult: true },
     ): Promise<mongodb.InsertManyResult<Require_id<DocContents>>>;
     insertMany<DocContents = TRawDocType>(
-      docs: Array<DocContents | TRawDocType>
-    ): Promise<Array<MergeType<THydratedDocumentType, Omit<DocContents, '_id'>>>>;
+      docs: Array<DocContents | TRawDocType>,
+    ): Promise<
+      Array<MergeType<THydratedDocumentType, Omit<DocContents, '_id'>>>
+    >;
     insertMany<DocContents = TRawDocType>(
       doc: DocContents,
-      options: InsertManyOptions & { lean: true; }
+      options: InsertManyOptions & { lean: true },
     ): Promise<Array<Require_id<DocContents>>>;
     insertMany<DocContents = TRawDocType>(
       doc: DocContents,
-      options: InsertManyOptions & { rawResult: true; }
+      options: InsertManyOptions & { rawResult: true },
     ): Promise<mongodb.InsertManyResult<Require_id<DocContents>>>;
     insertMany<DocContents = TRawDocType>(
       doc: DocContents,
-      options: InsertManyOptions
-    ): Promise<Array<MergeType<THydratedDocumentType, Omit<DocContents, '_id'>>>>;
+      options: InsertManyOptions,
+    ): Promise<
+      Array<MergeType<THydratedDocumentType, Omit<DocContents, '_id'>>>
+    >;
     insertMany<DocContents = TRawDocType>(
       docs: Array<DocContents | TRawDocType>,
-      options: InsertManyOptions
-    ): Promise<Array<MergeType<THydratedDocumentType, Omit<DocContents, '_id'>>>>;
+      options: InsertManyOptions,
+    ): Promise<
+      Array<MergeType<THydratedDocumentType, Omit<DocContents, '_id'>>>
+    >;
     insertMany<DocContents = TRawDocType>(
-      doc: DocContents
+      doc: DocContents,
     ): Promise<
       Array<MergeType<THydratedDocumentType, Omit<DocContents, '_id'>>>
     >;
@@ -580,7 +685,9 @@ declare module 'mongoose' {
      * List all [Atlas search indexes](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) on this model's collection.
      * This function only works when connected to MongoDB Atlas.
      */
-    listSearchIndexes(options?: mongodb.ListSearchIndexesOptions): Promise<Array<{ name: string }>>;
+    listSearchIndexes(
+      options?: mongodb.ListSearchIndexesOptions,
+    ): Promise<Array<{ name: string }>>;
 
     /** The name of the model */
     modelName: string;
@@ -588,17 +695,19 @@ declare module 'mongoose' {
     /** Populates document references. */
     populate(
       docs: Array<any>,
-      options: PopulateOptions | Array<PopulateOptions> | string
+      options: PopulateOptions | Array<PopulateOptions> | string,
     ): Promise<Array<THydratedDocumentType>>;
     populate(
-      doc: any, options: PopulateOptions | Array<PopulateOptions> | string
+      doc: any,
+      options: PopulateOptions | Array<PopulateOptions> | string,
     ): Promise<THydratedDocumentType>;
     populate<Paths>(
       docs: Array<any>,
-      options: PopulateOptions | Array<PopulateOptions> | string
+      options: PopulateOptions | Array<PopulateOptions> | string,
     ): Promise<Array<MergeType<THydratedDocumentType, Paths>>>;
     populate<Paths>(
-      doc: any, options: PopulateOptions | Array<PopulateOptions> | string
+      doc: any,
+      options: PopulateOptions | Array<PopulateOptions> | string,
     ): Promise<MergeType<THydratedDocumentType, Paths>>;
 
     /**
@@ -611,13 +720,31 @@ declare module 'mongoose' {
     validate(): Promise<void>;
     validate(obj: any): Promise<void>;
     validate(obj: any, pathsOrOptions: PathsToValidate): Promise<void>;
-    validate(obj: any, pathsOrOptions: { pathsToSkip?: pathsToSkip }): Promise<void>;
+    validate(
+      obj: any,
+      pathsOrOptions: { pathsToSkip?: pathsToSkip },
+    ): Promise<void>;
 
     /** Watches the underlying collection for changes using [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/). */
-    watch<ResultType extends mongodb.Document = any, ChangeType extends mongodb.ChangeStreamDocument = any>(pipeline?: Array<Record<string, unknown>>, options?: mongodb.ChangeStreamOptions & { hydrate?: boolean }): mongodb.ChangeStream<ResultType, ChangeType>;
+    watch<
+      ResultType extends mongodb.Document = any,
+      ChangeType extends mongodb.ChangeStreamDocument = any,
+    >(
+      pipeline?: Array<Record<string, unknown>>,
+      options?: mongodb.ChangeStreamOptions & { hydrate?: boolean },
+    ): mongodb.ChangeStream<ResultType, ChangeType>;
 
     /** Adds a `$where` clause to this query */
-    $where(argument: string | Function): QueryWithHelpers<Array<THydratedDocumentType>, THydratedDocumentType, TQueryHelpers, TRawDocType, 'find', TInstanceMethods>;
+    $where(
+      argument: string | Function,
+    ): QueryWithHelpers<
+      Array<THydratedDocumentType>,
+      THydratedDocumentType,
+      TQueryHelpers,
+      TRawDocType,
+      'find',
+      TInstanceMethods
+    >;
 
     /** Registered discriminators for this model. */
     discriminators: { [name: string]: Model<any> } | undefined;
@@ -629,11 +756,13 @@ declare module 'mongoose' {
     distinct<DocKey extends string, ResultType = unknown>(
       field: DocKey,
       filter?: RootFilterQuery<TRawDocType>,
-      options?: QueryOptions<TRawDocType>
+      options?: QueryOptions<TRawDocType>,
     ): QueryWithHelpers<
       Array<
         DocKey extends keyof WithLevel1NestedPaths<TRawDocType>
-          ? WithoutUndefined<Unpacked<WithLevel1NestedPaths<TRawDocType>[DocKey]>>
+          ? WithoutUndefined<
+              Unpacked<WithLevel1NestedPaths<TRawDocType>[DocKey]>
+            >
           : ResultType
       >,
       THydratedDocumentType,
@@ -644,7 +773,9 @@ declare module 'mongoose' {
     >;
 
     /** Creates a `estimatedDocumentCount` query: counts the number of documents in the collection. */
-    estimatedDocumentCount(options?: QueryOptions<TRawDocType>): QueryWithHelpers<
+    estimatedDocumentCount(
+      options?: QueryOptions<TRawDocType>,
+    ): QueryWithHelpers<
       number,
       THydratedDocumentType,
       TQueryHelpers,
@@ -658,7 +789,7 @@ declare module 'mongoose' {
      * the given `filter`, and `null` otherwise.
      */
     exists(
-      filter: RootFilterQuery<TRawDocType>
+      filter: RootFilterQuery<TRawDocType>,
     ): QueryWithHelpers<
       { _id: InferId<TRawDocType> } | null,
       THydratedDocumentType,
@@ -672,7 +803,7 @@ declare module 'mongoose' {
     find<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       projection: ProjectionType<TRawDocType> | null | undefined,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType[], 'find'>,
       ResultDoc,
@@ -684,22 +815,49 @@ declare module 'mongoose' {
     find<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       projection?: ProjectionType<TRawDocType> | null | undefined,
-      options?: QueryOptions<TRawDocType> | null | undefined
-    ): QueryWithHelpers<Array<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'find', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null | undefined,
+    ): QueryWithHelpers<
+      Array<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'find',
+      TInstanceMethods
+    >;
     find<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
-      projection?: ProjectionType<TRawDocType> | null | undefined
-    ): QueryWithHelpers<Array<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'find', TInstanceMethods>;
-    find<ResultDoc = THydratedDocumentType>(
-      filter: RootFilterQuery<TRawDocType>
-    ): QueryWithHelpers<Array<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'find', TInstanceMethods>;
+      projection?: ProjectionType<TRawDocType> | null | undefined,
+    ): QueryWithHelpers<
+      Array<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'find',
+      TInstanceMethods
+    >;
     find<ResultDoc = THydratedDocumentType>(
-    ): QueryWithHelpers<Array<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'find', TInstanceMethods>;
+      filter: RootFilterQuery<TRawDocType>,
+    ): QueryWithHelpers<
+      Array<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'find',
+      TInstanceMethods
+    >;
+    find<ResultDoc = THydratedDocumentType>(): QueryWithHelpers<
+      Array<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'find',
+      TInstanceMethods
+    >;
 
     /** Creates a `findByIdAndDelete` query, filtering by the given `_id`. */
     findByIdAndDelete<ResultDoc = THydratedDocumentType>(
       id: mongodb.ObjectId | any,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType, 'findOneAndDelete'> | null,
       ResultDoc,
@@ -710,18 +868,35 @@ declare module 'mongoose' {
     >;
     findByIdAndDelete<ResultDoc = THydratedDocumentType>(
       id: mongodb.ObjectId | any,
-      options: QueryOptions<TRawDocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<ModifyResult<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndDelete', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      ModifyResult<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndDelete',
+      TInstanceMethods
+    >;
     findByIdAndDelete<ResultDoc = THydratedDocumentType>(
       id?: mongodb.ObjectId | any,
-      options?: QueryOptions<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndDelete', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndDelete',
+      TInstanceMethods
+    >;
 
     /** Creates a `findOneAndUpdate` query, filtering by the given `_id`. */
     findByIdAndUpdate<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { includeResultMetadata: true, lean: true }
+      options: QueryOptions<TRawDocType> & {
+        includeResultMetadata: true;
+        lean: true;
+      },
     ): QueryWithHelpers<
       ModifyResult<TRawDocType>,
       ResultDoc,
@@ -733,7 +908,7 @@ declare module 'mongoose' {
     findByIdAndUpdate<ResultDoc = THydratedDocumentType>(
       id: mongodb.ObjectId | any,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType, 'findOneAndUpdate'> | null,
       ResultDoc,
@@ -745,27 +920,55 @@ declare module 'mongoose' {
     findByIdAndUpdate<ResultDoc = THydratedDocumentType>(
       id: mongodb.ObjectId | any,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<ModifyResult<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      ModifyResult<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findByIdAndUpdate<ResultDoc = THydratedDocumentType>(
       id: mongodb.ObjectId | any,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { upsert: true } & ReturnsNewDoc
-    ): QueryWithHelpers<ResultDoc, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { upsert: true } & ReturnsNewDoc,
+    ): QueryWithHelpers<
+      ResultDoc,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findByIdAndUpdate<ResultDoc = THydratedDocumentType>(
       id?: mongodb.ObjectId | any,
       update?: UpdateQuery<TRawDocType>,
-      options?: QueryOptions<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findByIdAndUpdate<ResultDoc = THydratedDocumentType>(
       id: mongodb.ObjectId | any,
-      update: UpdateQuery<TRawDocType>
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      update: UpdateQuery<TRawDocType>,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
 
     /** Creates a `findOneAndDelete` query: atomically finds the given document, deletes it, and returns the document as it was before deletion. */
     findOneAndDelete<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType, 'findOneAndDelete'> | null,
       ResultDoc,
@@ -776,18 +979,32 @@ declare module 'mongoose' {
     >;
     findOneAndDelete<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<ModifyResult<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndDelete', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      ModifyResult<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndDelete',
+      TInstanceMethods
+    >;
     findOneAndDelete<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType> | null,
-      options?: QueryOptions<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndDelete', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndDelete',
+      TInstanceMethods
+    >;
 
     /** Creates a `findOneAndReplace` query: atomically finds the given document and replaces it with `replacement`. */
     findOneAndReplace<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       replacement: TRawDocType | AnyObject,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType, 'findOneAndReplace'> | null,
       ResultDoc,
@@ -799,24 +1016,48 @@ declare module 'mongoose' {
     findOneAndReplace<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       replacement: TRawDocType | AnyObject,
-      options: QueryOptions<TRawDocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<ModifyResult<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndReplace', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      ModifyResult<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndReplace',
+      TInstanceMethods
+    >;
     findOneAndReplace<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       replacement: TRawDocType | AnyObject,
-      options: QueryOptions<TRawDocType> & { upsert: true } & ReturnsNewDoc
-    ): QueryWithHelpers<ResultDoc, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndReplace', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { upsert: true } & ReturnsNewDoc,
+    ): QueryWithHelpers<
+      ResultDoc,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndReplace',
+      TInstanceMethods
+    >;
     findOneAndReplace<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType>,
       replacement?: TRawDocType | AnyObject,
-      options?: QueryOptions<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndReplace', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndReplace',
+      TInstanceMethods
+    >;
 
     /** Creates a `findOneAndUpdate` query: atomically find the first document that matches `filter` and apply `update`. */
     findOneAndUpdate<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { includeResultMetadata: true, lean: true }
+      options: QueryOptions<TRawDocType> & {
+        includeResultMetadata: true;
+        lean: true;
+      },
     ): QueryWithHelpers<
       ModifyResult<TRawDocType>,
       ResultDoc,
@@ -828,7 +1069,7 @@ declare module 'mongoose' {
     findOneAndUpdate<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { lean: true }
+      options: QueryOptions<TRawDocType> & { lean: true },
     ): QueryWithHelpers<
       GetLeanResultType<TRawDocType, TRawDocType, 'findOneAndUpdate'> | null,
       ResultDoc,
@@ -840,25 +1081,55 @@ declare module 'mongoose' {
     findOneAndUpdate<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<ModifyResult<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      ModifyResult<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findOneAndUpdate<ResultDoc = THydratedDocumentType>(
       filter: RootFilterQuery<TRawDocType>,
       update: UpdateQuery<TRawDocType>,
-      options: QueryOptions<TRawDocType> & { upsert: true } & ReturnsNewDoc
-    ): QueryWithHelpers<ResultDoc, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<TRawDocType> & { upsert: true } & ReturnsNewDoc,
+    ): QueryWithHelpers<
+      ResultDoc,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findOneAndUpdate<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType>,
       update?: UpdateQuery<TRawDocType>,
-      options?: QueryOptions<TRawDocType> | null
-    ): QueryWithHelpers<ResultDoc | null, ResultDoc, TQueryHelpers, TRawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options?: QueryOptions<TRawDocType> | null,
+    ): QueryWithHelpers<
+      ResultDoc | null,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
 
     /** Creates a `replaceOne` query: finds the first document that matches `filter` and replaces it with `replacement`. */
     replaceOne<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType>,
       replacement?: TRawDocType | AnyObject,
-      options?: (mongodb.ReplaceOptions & MongooseQueryOptions<TRawDocType>) | null
-    ): QueryWithHelpers<UpdateWriteOpResult, ResultDoc, TQueryHelpers, TRawDocType, 'replaceOne', TInstanceMethods>;
+      options?:
+        | (mongodb.ReplaceOptions & MongooseQueryOptions<TRawDocType>)
+        | null,
+    ): QueryWithHelpers<
+      UpdateWriteOpResult,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'replaceOne',
+      TInstanceMethods
+    >;
 
     /** Apply changes made to this model's schema after this model was compiled. */
     recompileSchema(): void;
@@ -870,22 +1141,49 @@ declare module 'mongoose' {
     updateMany<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType>,
       update?: UpdateQuery<TRawDocType> | UpdateWithAggregationPipeline,
-      options?: (mongodb.UpdateOptions & MongooseUpdateQueryOptions<TRawDocType>) | null
-    ): QueryWithHelpers<UpdateWriteOpResult, ResultDoc, TQueryHelpers, TRawDocType, 'updateMany', TInstanceMethods>;
+      options?:
+        | (mongodb.UpdateOptions & MongooseUpdateQueryOptions<TRawDocType>)
+        | null,
+    ): QueryWithHelpers<
+      UpdateWriteOpResult,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'updateMany',
+      TInstanceMethods
+    >;
 
     /** Creates a `updateOne` query: updates the first document that matches `filter` with `update`. */
     updateOne<ResultDoc = THydratedDocumentType>(
       filter?: RootFilterQuery<TRawDocType>,
       update?: UpdateQuery<TRawDocType> | UpdateWithAggregationPipeline,
-      options?: (mongodb.UpdateOptions & MongooseUpdateQueryOptions<TRawDocType>) | null
-    ): QueryWithHelpers<UpdateWriteOpResult, ResultDoc, TQueryHelpers, TRawDocType, 'updateOne', TInstanceMethods>;
+      options?:
+        | (mongodb.UpdateOptions & MongooseUpdateQueryOptions<TRawDocType>)
+        | null,
+    ): QueryWithHelpers<
+      UpdateWriteOpResult,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'updateOne',
+      TInstanceMethods
+    >;
 
     /** Creates a Query, applies the passed conditions, and returns the Query. */
     where<ResultDoc = THydratedDocumentType>(
       path: string,
-      val?: any
-    ): QueryWithHelpers<Array<ResultDoc>, ResultDoc, TQueryHelpers, TRawDocType, 'find', TInstanceMethods>;
-    where<ResultDoc = THydratedDocumentType>(obj: object): QueryWithHelpers<
+      val?: any,
+    ): QueryWithHelpers<
+      Array<ResultDoc>,
+      ResultDoc,
+      TQueryHelpers,
+      TRawDocType,
+      'find',
+      TInstanceMethods
+    >;
+    where<ResultDoc = THydratedDocumentType>(
+      obj: object,
+    ): QueryWithHelpers<
       Array<ResultDoc>,
       ResultDoc,
       TQueryHelpers,
diff --git a/types/mongooseoptions.d.ts b/types/mongooseoptions.d.ts
index 9c35ab8222b969b8cfa3fa0be4f9aa20167dc66c..cac1cb4686fa72d906a6561527457e066be381eb 100644
--- a/types/mongooseoptions.d.ts
+++ b/types/mongooseoptions.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import stream = require('stream');
 
   interface MongooseOptions {
@@ -81,10 +81,14 @@ declare module 'mongoose' {
      * @default false
      */
     debug?:
-    | boolean
-    | { color?: boolean; shell?: boolean; }
-    | stream.Writable
-    | ((collectionName: string, methodName: string, ...methodArgs: any[]) => void);
+      | boolean
+      | { color?: boolean; shell?: boolean }
+      | stream.Writable
+      | ((
+          collectionName: string,
+          methodName: string,
+          ...methodArgs: any[]
+        ) => void);
 
     /**
      * If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.
@@ -98,7 +102,7 @@ declare module 'mongoose' {
      *
      * @default true
      */
-    'timestamps.createdAt.immutable'?: boolean
+    'timestamps.createdAt.immutable'?: boolean;
 
     /** If set, attaches [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/) to every query */
     maxTimeMS?: number;
diff --git a/types/pipelinestage.d.ts b/types/pipelinestage.d.ts
index c709528ec136142cf2546e47426e620addbadf89..4b5bf98147591e9e9e057c2232db5e70bb35d99c 100644
--- a/types/pipelinestage.d.ts
+++ b/types/pipelinestage.d.ts
@@ -1,7 +1,7 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   /**
-     * [Stages reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-stages)
-     */
+   * [Stages reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-stages)
+   */
   export type PipelineStage =
     | PipelineStage.AddFields
     | PipelineStage.Bucket
@@ -43,7 +43,7 @@ declare module 'mongoose' {
   export namespace PipelineStage {
     export interface AddFields {
       /** [`$addFields` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/) */
-      $addFields: Record<string, AnyExpression>
+      $addFields: Record<string, AnyExpression>;
     }
 
     export interface Bucket {
@@ -51,9 +51,9 @@ declare module 'mongoose' {
       $bucket: {
         groupBy: Expression;
         boundaries: any[];
-        default?: any
-        output?: Record<string, AccumulatorOperator>
-      }
+        default?: any;
+        output?: Record<string, AccumulatorOperator>;
+      };
     }
 
     export interface BucketAuto {
@@ -62,8 +62,21 @@ declare module 'mongoose' {
         groupBy: Expression | Record<string, Expression>;
         buckets: number;
         output?: Record<string, AccumulatorOperator>;
-        granularity?: 'R5' | 'R10' | 'R20' | 'R40' | 'R80' | '1-2-5' | 'E6' | 'E12' | 'E24' | 'E48' | 'E96' | 'E192' | 'POWERSOF2';
-      }
+        granularity?:
+          | 'R5'
+          | 'R10'
+          | 'R20'
+          | 'R40'
+          | 'R80'
+          | '1-2-5'
+          | 'E6'
+          | 'E12'
+          | 'E24'
+          | 'E48'
+          | 'E96'
+          | 'E192'
+          | 'POWERSOF2';
+      };
     }
 
     export interface CollStats {
@@ -73,7 +86,7 @@ declare module 'mongoose' {
         storageStats?: { scale?: number };
         count?: Record<string | number | symbol, never>;
         queryExecStats?: Record<string | number | symbol, never>;
-      }
+      };
     }
 
     export interface Count {
@@ -81,32 +94,44 @@ declare module 'mongoose' {
       $count: string;
     }
 
-    export interface Densify{
+    export interface Densify {
       /** [`$densify` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/) */
       $densify: {
-        field: string,
-        partitionByFields?: string[],
+        field: string;
+        partitionByFields?: string[];
         range: {
-          step: number,
-          unit?: 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year',
-          bounds: number[] | globalThis.Date[] | 'full' | 'partition'
-        }
-      }
+          step: number;
+          unit?:
+            | 'millisecond'
+            | 'second'
+            | 'minute'
+            | 'hour'
+            | 'day'
+            | 'week'
+            | 'month'
+            | 'quarter'
+            | 'year';
+          bounds: number[] | globalThis.Date[] | 'full' | 'partition';
+        };
+      };
     }
 
     export interface Documents {
       /** [`$documents` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/documents/) */
-      $documents: Record<string, Expression>[]
+      $documents: Record<string, Expression>[];
     }
 
     export interface Fill {
       /** [`$fill` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/) */
       $fill: {
-        partitionBy?: Expression,
-        partitionByFields?: string[],
-        sortBy?: Record<string, 1 | -1>,
-        output: Record<string, { value: Expression } | { method: 'linear' | 'locf' }>
-      }
+        partitionBy?: Expression;
+        partitionByFields?: string[];
+        sortBy?: Record<string, 1 | -1>;
+        output: Record<
+          string,
+          { value: Expression } | { method: 'linear' | 'locf' }
+        >;
+      };
     }
 
     export interface Facet {
@@ -114,12 +139,23 @@ declare module 'mongoose' {
       $facet: Record<string, FacetPipelineStage[]>;
     }
 
-    export type FacetPipelineStage = Exclude<PipelineStage, PipelineStage.CollStats | PipelineStage.Facet | PipelineStage.GeoNear | PipelineStage.IndexStats | PipelineStage.Out | PipelineStage.Merge | PipelineStage.PlanCacheStats>;
+    export type FacetPipelineStage = Exclude<
+      PipelineStage,
+      | PipelineStage.CollStats
+      | PipelineStage.Facet
+      | PipelineStage.GeoNear
+      | PipelineStage.IndexStats
+      | PipelineStage.Out
+      | PipelineStage.Merge
+      | PipelineStage.PlanCacheStats
+    >;
 
     export interface GeoNear {
       /** [`$geoNear` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/geoNear/) */
       $geoNear: {
-        near: { type: 'Point'; coordinates: [number, number] } | [number, number];
+        near:
+          | { type: 'Point'; coordinates: [number, number] }
+          | [number, number];
         distanceField: string;
         distanceMultiplier?: number;
         includeLocs?: string;
@@ -133,26 +169,26 @@ declare module 'mongoose' {
          * @deprecated
          */
         num?: number;
-      }
+      };
     }
 
     export interface GraphLookup {
       /** [`$graphLookup` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/) */
       $graphLookup: {
         from: string;
-        startWith: any
+        startWith: any;
         connectFromField: string;
         connectToField: string;
         as: string;
         maxDepth?: number;
         depthField?: string;
         restrictSearchWithMatch?: AnyObject;
-      }
+      };
     }
 
     export interface Group {
       /** [`$group` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group) */
-      $group: { _id: any } | { [key: string]: AccumulatorOperator }
+      $group: { _id: any } | { [key: string]: AccumulatorOperator };
     }
 
     export interface IndexStats {
@@ -162,24 +198,29 @@ declare module 'mongoose' {
 
     export interface Limit {
       /** [`$limit` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/limit/) */
-      $limit: number
+      $limit: number;
     }
 
     export interface ListSessions {
       /** [`$listSessions` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/listSessions/) */
-      $listSessions: { users?: { user: string; db: string }[] } | { allUsers?: true }
+      $listSessions:
+        | { users?: { user: string; db: string }[] }
+        | { allUsers?: true };
     }
 
     export interface Lookup {
       /** [`$lookup` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/) */
       $lookup: {
-        from: string
-        as: string
-        localField?: string
-        foreignField?: string
-        let?: Record<string, any>
-        pipeline?: Exclude<PipelineStage, PipelineStage.Merge | PipelineStage.Out>[]
-      }
+        from: string;
+        as: string;
+        localField?: string;
+        foreignField?: string;
+        let?: Record<string, any>;
+        pipeline?: Exclude<
+          PipelineStage,
+          PipelineStage.Merge | PipelineStage.Out
+        >[];
+      };
     }
 
     export interface Match {
@@ -190,27 +231,42 @@ declare module 'mongoose' {
     export interface Merge {
       /** [`$merge` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/merge/) */
       $merge: {
-        into: string | { db: string; coll: string }
-        on?: string | string[]
-        let?: Record<string, Expression>
-        whenMatched?: 'replace' | 'keepExisting' | 'merge' | 'fail' | Extract<PipelineStage, PipelineStage.AddFields | PipelineStage.Set | PipelineStage.Project | PipelineStage.Unset | PipelineStage.ReplaceRoot | PipelineStage.ReplaceWith>[]
-        whenNotMatched?: 'insert' | 'discard' | 'fail'
-      }
+        into: string | { db: string; coll: string };
+        on?: string | string[];
+        let?: Record<string, Expression>;
+        whenMatched?:
+          | 'replace'
+          | 'keepExisting'
+          | 'merge'
+          | 'fail'
+          | Extract<
+              PipelineStage,
+              | PipelineStage.AddFields
+              | PipelineStage.Set
+              | PipelineStage.Project
+              | PipelineStage.Unset
+              | PipelineStage.ReplaceRoot
+              | PipelineStage.ReplaceWith
+            >[];
+        whenNotMatched?: 'insert' | 'discard' | 'fail';
+      };
     }
 
     export interface Out {
       /** [`$out` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/out/) */
-      $out: string | { db: string; coll: string }
+      $out: string | { db: string; coll: string };
     }
 
     export interface PlanCacheStats {
       /** [`$planCacheStats` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/planCacheStats/) */
-      $planCacheStats: Record<string | number | symbol, never>
+      $planCacheStats: Record<string | number | symbol, never>;
     }
 
     export interface Project {
       /** [`$project` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) */
-      $project: { [field: string]: AnyExpression | Expression | Project['$project'] }
+      $project: {
+        [field: string]: AnyExpression | Expression | Project['$project'];
+      };
     }
 
     export interface Redact {
@@ -220,17 +276,20 @@ declare module 'mongoose' {
 
     export interface ReplaceRoot {
       /** [`$replaceRoot` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot/) */
-      $replaceRoot: { newRoot: AnyExpression }
+      $replaceRoot: { newRoot: AnyExpression };
     }
 
     export interface ReplaceWith {
       /** [`$replaceWith` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceWith/) */
-      $replaceWith: ObjectExpressionOperator | { [field: string]: Expression } | `$${string}`;
+      $replaceWith:
+        | ObjectExpressionOperator
+        | { [field: string]: Expression }
+        | `$${string}`;
     }
 
     export interface Sample {
       /** [`$sample` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/) */
-      $sample: { size: number }
+      $sample: { size: number };
     }
 
     export interface Search {
@@ -239,12 +298,12 @@ declare module 'mongoose' {
         index?: string;
         highlight?: {
           /** [`highlightPath` reference](https://docs.atlas.mongodb.com/atlas-search/path-construction/#multiple-field-search) */
-          path: string | string[] | { value: string, multi: string };
+          path: string | string[] | { value: string; multi: string };
           maxCharsToExamine?: number;
           maxNumPassages?: number;
         };
         [operator: string]: any;
-      }
+      };
     }
 
     export interface SearchMeta {
@@ -253,45 +312,54 @@ declare module 'mongoose' {
         index?: string;
         highlight?: {
           /** [`highlightPath` reference](https://docs.atlas.mongodb.com/atlas-search/path-construction/#multiple-field-search) */
-          path: string | string[] | { value: string, multi: string };
+          path: string | string[] | { value: string; multi: string };
           maxCharsToExamine?: number;
           maxNumPassages?: number;
         };
         [operator: string]: any;
-      }
+      };
     }
 
     export interface Set {
       /** [`$set` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/set/) */
-      $set: Record<string, AnyExpression | any>
+      $set: Record<string, AnyExpression | any>;
     }
 
     export interface SetWindowFields {
       /** [`$setWindowFields` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/setWindowFields/) */
       $setWindowFields: {
-        partitionBy?: any
-        sortBy?: Record<string, 1 | -1>
+        partitionBy?: any;
+        sortBy?: Record<string, 1 | -1>;
         output: Record<
-        string,
-        WindowOperator & {
-          window?: {
-            documents?: [string | number, string | number]
-            range?: [string | number, string | number]
-            unit?: 'year' | 'quarter' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond'
+          string,
+          WindowOperator & {
+            window?: {
+              documents?: [string | number, string | number];
+              range?: [string | number, string | number];
+              unit?:
+                | 'year'
+                | 'quarter'
+                | 'month'
+                | 'week'
+                | 'day'
+                | 'hour'
+                | 'minute'
+                | 'second'
+                | 'millisecond';
+            };
           }
-        }
-        >
-      }
+        >;
+      };
     }
 
     export interface Skip {
       /** [`$skip` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/skip/) */
-      $skip: number
+      $skip: number;
     }
 
     export interface Sort {
       /** [`$sort` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sort/) */
-      $sort: Record<string, 1 | -1 | Expression.Meta>
+      $sort: Record<string, 1 | -1 | Expression.Meta>;
     }
 
     export interface SortByCount {
@@ -302,31 +370,48 @@ declare module 'mongoose' {
     export interface UnionWith {
       /** [`$unionWith` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unionWith/) */
       $unionWith:
-      | string
-      | { coll: string; pipeline?: Exclude<PipelineStage, PipelineStage.Out | PipelineStage.Merge>[] }
-      | { coll?: string; pipeline: Exclude<PipelineStage, PipelineStage.Out | PipelineStage.Merge>[] }
+        | string
+        | {
+            coll: string;
+            pipeline?: Exclude<
+              PipelineStage,
+              PipelineStage.Out | PipelineStage.Merge
+            >[];
+          }
+        | {
+            coll?: string;
+            pipeline: Exclude<
+              PipelineStage,
+              PipelineStage.Out | PipelineStage.Merge
+            >[];
+          };
     }
 
     export interface Unset {
       /** [`$unset` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unset/) */
-      $unset: string | string[]
+      $unset: string | string[];
     }
 
     export interface Unwind {
       /** [`$unwind` reference](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/) */
-      $unwind: string | { path: string; includeArrayIndex?: string; preserveNullAndEmptyArrays?: boolean }
+      $unwind:
+        | string
+        | {
+            path: string;
+            includeArrayIndex?: string;
+            preserveNullAndEmptyArrays?: boolean;
+          };
     }
     export interface VectorSearch {
       /** [`$vectorSearch` reference](https://www.mongodb.com/docs/atlas/atlas-vector-search/vector-search-stage/) */
       $vectorSearch: {
-        index: string,
-        path: string,
-        queryVector: number[],
-        numCandidates: number,
-        limit: number,
-        filter?: Expression,
-      }
+        index: string;
+        path: string;
+        queryVector: number[];
+        numCandidates: number;
+        limit: number;
+        filter?: Expression;
+      };
     }
-
   }
 }
diff --git a/types/populate.d.ts b/types/populate.d.ts
index 0db038014f9de9a7244cbd99858c55e4054a41fe..9126f0390c676168f5f6f1c739bce6cf3678dc3b 100644
--- a/types/populate.d.ts
+++ b/types/populate.d.ts
@@ -1,11 +1,14 @@
-declare module 'mongoose' {
-
+declare module 'mongoose-v8' {
   /**
    * Reference another Model
    */
   type PopulatedDoc<
     PopulatedType,
-    RawId extends RefType = (PopulatedType extends { _id?: RefType; } ? NonNullable<PopulatedType['_id']> : Types.ObjectId) | undefined
+    RawId extends RefType =
+      | (PopulatedType extends { _id?: RefType }
+          ? NonNullable<PopulatedType['_id']>
+          : Types.ObjectId)
+      | undefined,
   > = PopulatedType | RawId;
 
   interface PopulateOptions {
diff --git a/types/query.d.ts b/types/query.d.ts
index 67129e6c7b643a5a1b57bc2dc2e22803f003f72f..28acd49ebdc2277a4488b5e93e24e61497260df8 100644
--- a/types/query.d.ts
+++ b/types/query.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   export type Condition<T> = T | QuerySelector<T | any> | any;
@@ -14,7 +14,7 @@ declare module 'mongoose' {
 
   type FilterQuery<T> = {
     [P in keyof T]?: Condition<T[P]>;
-  } & RootQuerySelector<T> & { _id?: Condition<string>; };
+  } & RootQuerySelector<T> & { _id?: Condition<string> };
 
   type MongooseBaseQueryOptionKeys =
     | 'context'
@@ -32,19 +32,28 @@ declare module 'mongoose' {
 
   type MongooseQueryOptions<
     DocType = unknown,
-    Keys extends keyof QueryOptions<DocType> = MongooseBaseQueryOptionKeys | 'timestamps' | 'lean'
+    Keys extends keyof QueryOptions<DocType> =
+      | MongooseBaseQueryOptionKeys
+      | 'timestamps'
+      | 'lean',
   > = Pick<QueryOptions<DocType>, Keys> & {
     [other: string]: any;
   };
 
-  type MongooseBaseQueryOptions<DocType = unknown> = MongooseQueryOptions<DocType, MongooseBaseQueryOptionKeys>;
+  type MongooseBaseQueryOptions<DocType = unknown> = MongooseQueryOptions<
+    DocType,
+    MongooseBaseQueryOptionKeys
+  >;
 
   type MongooseUpdateQueryOptions<DocType = unknown> = MongooseQueryOptions<
     DocType,
     MongooseBaseQueryOptionKeys | 'timestamps'
   >;
 
-  type ProjectionFields<DocType> = { [Key in keyof DocType]?: any } & Record<string, any>;
+  type ProjectionFields<DocType> = { [Key in keyof DocType]?: any } & Record<
+    string,
+    any
+  >;
 
   type QueryWithHelpers<
     ResultType,
@@ -52,8 +61,16 @@ declare module 'mongoose' {
     THelpers = {},
     RawDocType = DocType,
     QueryOp = 'find',
-    TInstanceMethods = Record<string, never>
-  > = Query<ResultType, DocType, THelpers, RawDocType, QueryOp, TInstanceMethods> & THelpers;
+    TInstanceMethods = Record<string, never>,
+  > = Query<
+    ResultType,
+    DocType,
+    THelpers,
+    RawDocType,
+    QueryOp,
+    TInstanceMethods
+  > &
+    THelpers;
 
   type QuerySelector<T> = {
     // Comparison
@@ -127,9 +144,9 @@ declare module 'mongoose' {
     updatedAt?: boolean;
   }
 
-  interface QueryOptions<DocType = unknown> extends
-    PopulateOption,
-    SessionOption {
+  interface QueryOptions<DocType = unknown>
+    extends PopulateOption,
+      SessionOption {
     arrayFilters?: { [key: string]: any }[];
     batchSize?: number;
     collation?: mongodb.CollationOptions;
@@ -214,25 +231,56 @@ declare module 'mongoose' {
     [other: string]: any;
   }
 
-  type QueryOpThatReturnsDocument = 'find' | 'findOne' | 'findOneAndUpdate' | 'findOneAndReplace' | 'findOneAndDelete';
-
-  type GetLeanResultType<RawDocType, ResultType, QueryOp> = QueryOp extends QueryOpThatReturnsDocument
-    ? (ResultType extends any[] ? Default__v<Require_id<BufferToBinary<FlattenMaps<RawDocType>>>>[] : Default__v<Require_id<BufferToBinary<FlattenMaps<RawDocType>>>>)
-    : ResultType;
-
-  type MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, TQueryHelpers, TInstanceMethods = Record<string, never>> = QueryOp extends QueryOpThatReturnsDocument
+  type QueryOpThatReturnsDocument =
+    | 'find'
+    | 'findOne'
+    | 'findOneAndUpdate'
+    | 'findOneAndReplace'
+    | 'findOneAndDelete';
+
+  type GetLeanResultType<RawDocType, ResultType, QueryOp> =
+    QueryOp extends QueryOpThatReturnsDocument
+      ? ResultType extends any[]
+        ? Default__v<Require_id<BufferToBinary<FlattenMaps<RawDocType>>>>[]
+        : Default__v<Require_id<BufferToBinary<FlattenMaps<RawDocType>>>>
+      : ResultType;
+
+  type MergePopulatePaths<
+    RawDocType,
+    ResultType,
+    QueryOp,
+    Paths,
+    TQueryHelpers,
+    TInstanceMethods = Record<string, never>,
+  > = QueryOp extends QueryOpThatReturnsDocument
     ? ResultType extends null
       ? ResultType
       : ResultType extends (infer U)[]
         ? U extends Document
-          ? HydratedDocument<MergeType<RawDocType, Paths>, TInstanceMethods, TQueryHelpers>[]
-          : (MergeType<U, Paths>)[]
+          ? HydratedDocument<
+              MergeType<RawDocType, Paths>,
+              TInstanceMethods,
+              TQueryHelpers
+            >[]
+          : MergeType<U, Paths>[]
         : ResultType extends Document
-          ? HydratedDocument<MergeType<RawDocType, Paths>, TInstanceMethods, TQueryHelpers>
+          ? HydratedDocument<
+              MergeType<RawDocType, Paths>,
+              TInstanceMethods,
+              TQueryHelpers
+            >
           : MergeType<ResultType, Paths>
     : MergeType<ResultType, Paths>;
 
-  class Query<ResultType, DocType, THelpers = {}, RawDocType = unknown, QueryOp = 'find', TInstanceMethods = Record<string, never>> implements SessionOperation {
+  class Query<
+    ResultType,
+    DocType,
+    THelpers = {},
+    RawDocType = unknown,
+    QueryOp = 'find',
+    TInstanceMethods = Record<string, never>,
+  > implements SessionOperation
+  {
     _mongooseOptions: MongooseQueryOptions<DocType>;
 
     /**
@@ -245,7 +293,9 @@ declare module 'mongoose' {
     /** Executes the query */
     exec(): Promise<ResultType>;
 
-    $where(argument: string | Function): QueryWithHelpers<
+    $where(
+      argument: string | Function,
+    ): QueryWithHelpers<
       DocType[],
       DocType,
       THelpers,
@@ -312,14 +362,23 @@ declare module 'mongoose' {
     /** Specifies this query as a `countDocuments` query. */
     countDocuments(
       criteria?: RootFilterQuery<RawDocType>,
-      options?: QueryOptions<DocType>
-    ): QueryWithHelpers<number, DocType, THelpers, RawDocType, 'countDocuments', TInstanceMethods>;
+      options?: QueryOptions<DocType>,
+    ): QueryWithHelpers<
+      number,
+      DocType,
+      THelpers,
+      RawDocType,
+      'countDocuments',
+      TInstanceMethods
+    >;
 
     /**
      * Returns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html).
      * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.
      */
-    cursor(options?: QueryOptions<DocType>): Cursor<Unpacked<ResultType>, QueryOptions<DocType>>;
+    cursor(
+      options?: QueryOptions<DocType>,
+    ): Cursor<Unpacked<ResultType>, QueryOptions<DocType>>;
 
     /**
      * Declare and/or execute this query as a `deleteMany()` operation. Works like
@@ -328,9 +387,26 @@ declare module 'mongoose' {
      */
     deleteMany(
       filter?: RootFilterQuery<RawDocType>,
-      options?: QueryOptions<DocType>
-    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteMany', TInstanceMethods>;
-    deleteMany(filter: RootFilterQuery<RawDocType>): QueryWithHelpers<
+      options?: QueryOptions<DocType>,
+    ): QueryWithHelpers<
+      any,
+      DocType,
+      THelpers,
+      RawDocType,
+      'deleteMany',
+      TInstanceMethods
+    >;
+    deleteMany(
+      filter: RootFilterQuery<RawDocType>,
+    ): QueryWithHelpers<
+      any,
+      DocType,
+      THelpers,
+      RawDocType,
+      'deleteMany',
+      TInstanceMethods
+    >;
+    deleteMany(): QueryWithHelpers<
       any,
       DocType,
       THelpers,
@@ -338,7 +414,6 @@ declare module 'mongoose' {
       'deleteMany',
       TInstanceMethods
     >;
-    deleteMany(): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteMany', TInstanceMethods>;
 
     /**
      * Declare and/or execute this query as a `deleteOne()` operation. Works like
@@ -347,9 +422,26 @@ declare module 'mongoose' {
      */
     deleteOne(
       filter?: RootFilterQuery<RawDocType>,
-      options?: QueryOptions<DocType>
-    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteOne', TInstanceMethods>;
-    deleteOne(filter: RootFilterQuery<RawDocType>): QueryWithHelpers<
+      options?: QueryOptions<DocType>,
+    ): QueryWithHelpers<
+      any,
+      DocType,
+      THelpers,
+      RawDocType,
+      'deleteOne',
+      TInstanceMethods
+    >;
+    deleteOne(
+      filter: RootFilterQuery<RawDocType>,
+    ): QueryWithHelpers<
+      any,
+      DocType,
+      THelpers,
+      RawDocType,
+      'deleteOne',
+      TInstanceMethods
+    >;
+    deleteOne(): QueryWithHelpers<
       any,
       DocType,
       THelpers,
@@ -357,13 +449,12 @@ declare module 'mongoose' {
       'deleteOne',
       TInstanceMethods
     >;
-    deleteOne(): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'deleteOne', TInstanceMethods>;
 
     /** Creates a `distinct` query: returns the distinct values of the given `field` that match `filter`. */
     distinct<DocKey extends string, ResultType = unknown>(
       field: DocKey,
       filter?: RootFilterQuery<RawDocType>,
-      options?: QueryOptions<DocType>
+      options?: QueryOptions<DocType>,
     ): QueryWithHelpers<
       Array<
         DocKey extends keyof WithLevel1NestedPaths<DocType>
@@ -392,7 +483,9 @@ declare module 'mongoose' {
     equals(val: any): this;
 
     /** Creates a `estimatedDocumentCount` query: counts the number of documents in the collection. */
-    estimatedDocumentCount(options?: QueryOptions<DocType>): QueryWithHelpers<
+    estimatedDocumentCount(
+      options?: QueryOptions<DocType>,
+    ): QueryWithHelpers<
       number,
       DocType,
       THelpers,
@@ -417,101 +510,240 @@ declare module 'mongoose' {
     find(
       filter: RootFilterQuery<RawDocType>,
       projection?: ProjectionType<RawDocType> | null,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      Array<DocType>,
+      DocType,
+      THelpers,
+      RawDocType,
+      'find',
+      TInstanceMethods
+    >;
     find(
       filter: RootFilterQuery<RawDocType>,
-      projection?: ProjectionType<RawDocType> | null
-    ): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TInstanceMethods>;
+      projection?: ProjectionType<RawDocType> | null,
+    ): QueryWithHelpers<
+      Array<DocType>,
+      DocType,
+      THelpers,
+      RawDocType,
+      'find',
+      TInstanceMethods
+    >;
     find(
-      filter: RootFilterQuery<RawDocType>
-    ): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TInstanceMethods>;
-    find(): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType, 'find', TInstanceMethods>;
+      filter: RootFilterQuery<RawDocType>,
+    ): QueryWithHelpers<
+      Array<DocType>,
+      DocType,
+      THelpers,
+      RawDocType,
+      'find',
+      TInstanceMethods
+    >;
+    find(): QueryWithHelpers<
+      Array<DocType>,
+      DocType,
+      THelpers,
+      RawDocType,
+      'find',
+      TInstanceMethods
+    >;
 
     /** Declares the query a findOne operation. When executed, returns the first found document. */
     findOne(
       filter?: RootFilterQuery<RawDocType>,
       projection?: ProjectionType<RawDocType> | null,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
     findOne(
       filter?: RootFilterQuery<RawDocType>,
-      projection?: ProjectionType<RawDocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TInstanceMethods>;
+      projection?: ProjectionType<RawDocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
     findOne(
-      filter?: RootFilterQuery<RawDocType>
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TInstanceMethods>;
+      filter?: RootFilterQuery<RawDocType>,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
 
     /** Creates a `findOneAndDelete` query: atomically finds the given document, deletes it, and returns the document as it was before deletion. */
     findOneAndDelete(
       filter?: RootFilterQuery<RawDocType>,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndDelete'>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndDelete'
+    >;
 
     /** Creates a `findOneAndUpdate` query: atomically find the first document that matches `filter` and apply `update`. */
     findOneAndUpdate(
       filter: RootFilterQuery<RawDocType>,
       update: UpdateQuery<RawDocType>,
-      options: QueryOptions<DocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<ModifyResult<DocType>, DocType, THelpers, RawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<DocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      ModifyResult<DocType>,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findOneAndUpdate(
       filter: RootFilterQuery<RawDocType>,
       update: UpdateQuery<RawDocType>,
-      options: QueryOptions<DocType> & { upsert: true } & ReturnsNewDoc
-    ): QueryWithHelpers<DocType, DocType, THelpers, RawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<DocType> & { upsert: true } & ReturnsNewDoc,
+    ): QueryWithHelpers<
+      DocType,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findOneAndUpdate(
       filter?: RootFilterQuery<RawDocType>,
       update?: UpdateQuery<RawDocType>,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
 
     /** Declares the query a findById operation. When executed, returns the document with the given `_id`. */
     findById(
       id: mongodb.ObjectId | any,
       projection?: ProjectionType<RawDocType> | null,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
     findById(
       id: mongodb.ObjectId | any,
-      projection?: ProjectionType<RawDocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TInstanceMethods>;
+      projection?: ProjectionType<RawDocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
     findById(
-      id: mongodb.ObjectId | any
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOne', TInstanceMethods>;
+      id: mongodb.ObjectId | any,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOne',
+      TInstanceMethods
+    >;
 
     /** Creates a `findByIdAndDelete` query, filtering by the given `_id`. */
     findByIdAndDelete(
       id: mongodb.ObjectId | any,
-      options: QueryOptions<DocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<ModifyResult<DocType>, DocType, THelpers, RawDocType, 'findOneAndDelete', TInstanceMethods>;
+      options: QueryOptions<DocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      ModifyResult<DocType>,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndDelete',
+      TInstanceMethods
+    >;
     findByIdAndDelete(
       id?: mongodb.ObjectId | any,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndDelete', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndDelete',
+      TInstanceMethods
+    >;
 
     /** Creates a `findOneAndUpdate` query, filtering by the given `_id`. */
     findByIdAndUpdate(
       id: mongodb.ObjectId | any,
       update: UpdateQuery<RawDocType>,
-      options: QueryOptions<DocType> & { includeResultMetadata: true }
-    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<DocType> & { includeResultMetadata: true },
+    ): QueryWithHelpers<
+      any,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findByIdAndUpdate(
       id: mongodb.ObjectId | any,
       update: UpdateQuery<RawDocType>,
-      options: QueryOptions<DocType> & { upsert: true } & ReturnsNewDoc
-    ): QueryWithHelpers<DocType, DocType, THelpers, RawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options: QueryOptions<DocType> & { upsert: true } & ReturnsNewDoc,
+    ): QueryWithHelpers<
+      DocType,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findByIdAndUpdate(
       id?: mongodb.ObjectId | any,
       update?: UpdateQuery<RawDocType>,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
     findByIdAndUpdate(
       id: mongodb.ObjectId | any,
-      update: UpdateQuery<RawDocType>
-    ): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate', TInstanceMethods>;
+      update: UpdateQuery<RawDocType>,
+    ): QueryWithHelpers<
+      DocType | null,
+      DocType,
+      THelpers,
+      RawDocType,
+      'findOneAndUpdate',
+      TInstanceMethods
+    >;
 
     /** Specifies a `$geometry` condition */
-    geometry(object: { type: string, coordinates: any[] }): this;
+    geometry(object: { type: string; coordinates: any[] }): this;
 
     /**
      * For update operations, returns the value of a path in the update's `$set`.
@@ -558,7 +790,7 @@ declare module 'mongoose' {
 
     /** Sets the lean option. */
     lean(
-      val?: boolean | any
+      val?: boolean | any,
     ): QueryWithHelpers<
       ResultType extends null
         ? GetLeanResultType<RawDocType, ResultType, QueryOp> | null
@@ -568,19 +800,17 @@ declare module 'mongoose' {
       RawDocType,
       QueryOp,
       TInstanceMethods
-      >;
+    >;
     lean<LeanResultType>(
-      val?: boolean | any
+      val?: boolean | any,
     ): QueryWithHelpers<
-      ResultType extends null
-        ? LeanResultType | null
-        : LeanResultType,
+      ResultType extends null ? LeanResultType | null : LeanResultType,
       DocType,
       THelpers,
       RawDocType,
       QueryOp,
       TInstanceMethods
-      >;
+    >;
 
     /** Specifies the maximum number of documents the query will return. */
     limit(val: number): this;
@@ -597,7 +827,16 @@ declare module 'mongoose' {
      * Runs a function `fn` and treats the return value of `fn` as the new value
      * for the query to resolve to.
      */
-    transform<MappedType>(fn: (doc: ResultType) => MappedType): QueryWithHelpers<MappedType, DocType, THelpers, RawDocType, QueryOp, TInstanceMethods>;
+    transform<MappedType>(
+      fn: (doc: ResultType) => MappedType,
+    ): QueryWithHelpers<
+      MappedType,
+      DocType,
+      THelpers,
+      RawDocType,
+      QueryOp,
+      TInstanceMethods
+    >;
 
     /** Specifies an `$maxDistance` query condition. When called with one argument, the most recent path passed to `where()` is used. */
     maxDistance(path: string, val: number): this;
@@ -649,7 +888,16 @@ declare module 'mongoose' {
      * This is handy for integrating with async/await, because `orFail()` saves you
      * an extra `if` statement to check if no document was found.
      */
-    orFail(err?: NativeError | (() => NativeError)): QueryWithHelpers<NonNullable<ResultType>, DocType, THelpers, RawDocType, QueryOp, TInstanceMethods>;
+    orFail(
+      err?: NativeError | (() => NativeError),
+    ): QueryWithHelpers<
+      NonNullable<ResultType>,
+      DocType,
+      THelpers,
+      RawDocType,
+      QueryOp,
+      TInstanceMethods
+    >;
 
     /** Specifies a `$polygon` condition */
     polygon(path: string, ...coordinatePairs: number[][]): this;
@@ -660,7 +908,7 @@ declare module 'mongoose' {
       path: string | string[],
       select?: string | any,
       model?: string | Model<any, THelpers>,
-      match?: any
+      match?: any,
     ): QueryWithHelpers<
       ResultType,
       DocType,
@@ -670,7 +918,7 @@ declare module 'mongoose' {
       TInstanceMethods
     >;
     populate(
-      options: PopulateOptions | (PopulateOptions | string)[]
+      options: PopulateOptions | (PopulateOptions | string)[],
     ): QueryWithHelpers<
       ResultType,
       DocType,
@@ -683,9 +931,16 @@ declare module 'mongoose' {
       path: string | string[],
       select?: string | any,
       model?: string | Model<any, THelpers>,
-      match?: any
+      match?: any,
     ): QueryWithHelpers<
-      MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, THelpers, TInstanceMethods>,
+      MergePopulatePaths<
+        RawDocType,
+        ResultType,
+        QueryOp,
+        Paths,
+        THelpers,
+        TInstanceMethods
+      >,
       DocType,
       THelpers,
       UnpackedIntersection<RawDocType, Paths>,
@@ -693,9 +948,16 @@ declare module 'mongoose' {
       TInstanceMethods
     >;
     populate<Paths>(
-      options: PopulateOptions | (PopulateOptions | string)[]
+      options: PopulateOptions | (PopulateOptions | string)[],
     ): QueryWithHelpers<
-      MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, THelpers, TInstanceMethods>,
+      MergePopulatePaths<
+        RawDocType,
+        ResultType,
+        QueryOp,
+        Paths,
+        THelpers,
+        TInstanceMethods
+      >,
       DocType,
       THelpers,
       UnpackedIntersection<RawDocType, Paths>,
@@ -710,7 +972,9 @@ declare module 'mongoose' {
     post(fn: Function): this;
 
     /** Get/set the current projection (AKA fields). Pass `null` to remove the current projection. */
-    projection(fields?: ProjectionFields<DocType> | string): ProjectionFields<DocType>;
+    projection(
+      fields?: ProjectionFields<DocType> | string,
+    ): ProjectionFields<DocType>;
     projection(fields: null): null;
     projection(): ProjectionFields<DocType> | null;
 
@@ -732,8 +996,15 @@ declare module 'mongoose' {
     replaceOne(
       filter?: RootFilterQuery<RawDocType>,
       replacement?: DocType | AnyObject,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<any, DocType, THelpers, RawDocType, 'replaceOne', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      any,
+      DocType,
+      THelpers,
+      RawDocType,
+      'replaceOne',
+      TInstanceMethods
+    >;
 
     /**
      * Sets this query's `sanitizeProjection` option. With `sanitizeProjection()`, you can pass potentially untrusted user data to `.select()`.
@@ -748,7 +1019,10 @@ declare module 'mongoose' {
 
     /** Specifies which document fields to include or exclude (also known as the query "projection") */
     select<RawDocTypeOverride extends { [P in keyof RawDocType]?: any } = {}>(
-      arg: string | string[] | Record<string, number | boolean | string | object>
+      arg:
+        | string
+        | string[]
+        | Record<string, number | boolean | string | object>,
     ): QueryWithHelpers<
       IfEquals<
         RawDocTypeOverride,
@@ -758,18 +1032,15 @@ declare module 'mongoose' {
           ? ResultType extends HydratedDocument<any>[]
             ? HydratedDocument<RawDocTypeOverride>[]
             : RawDocTypeOverride[]
-          : (ResultType extends HydratedDocument<any>
-            ? HydratedDocument<RawDocTypeOverride>
-            : RawDocTypeOverride) | (null extends ResultType ? null : never)
+          :
+              | (ResultType extends HydratedDocument<any>
+                  ? HydratedDocument<RawDocTypeOverride>
+                  : RawDocTypeOverride)
+              | (null extends ResultType ? null : never)
       >,
       DocType,
       THelpers,
-      IfEquals<
-        RawDocTypeOverride,
-        {},
-        RawDocType,
-        RawDocTypeOverride
-      >,
+      IfEquals<RawDocTypeOverride, {}, RawDocType, RawDocTypeOverride>,
       QueryOp,
       TInstanceMethods
     >;
@@ -803,7 +1074,9 @@ declare module 'mongoose' {
     /** Sets the query conditions to the provided JSON object. */
     setQuery(val: FilterQuery<RawDocType> | null): void;
 
-    setUpdate(update: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline): void;
+    setUpdate(
+      update: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline,
+    ): void;
 
     /** Specifies an `$size` query condition. When called with one argument, the most recent path passed to `where()` is used. */
     size<K = string>(path: K, val: number): this;
@@ -818,15 +1091,23 @@ declare module 'mongoose' {
 
     /** Sets the sort order. If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`. */
     sort(
-      arg?: string | { [key: string]: SortOrder | { $meta: any } } | [string, SortOrder][] | undefined | null,
-      options?: { override?: boolean }
+      arg?:
+        | string
+        | { [key: string]: SortOrder | { $meta: any } }
+        | [string, SortOrder][]
+        | undefined
+        | null,
+      options?: { override?: boolean },
     ): this;
 
     /** Sets the tailable option (for use with capped collections). */
-    tailable(bool?: boolean, opts?: {
-      numberOfRetries?: number;
-      tailableRetryInterval?: number;
-    }): this;
+    tailable(
+      bool?: boolean,
+      opts?: {
+        numberOfRetries?: number;
+        tailableRetryInterval?: number;
+      },
+    ): this;
 
     /**
      * Executes the query returning a `Promise` which will be
@@ -846,8 +1127,15 @@ declare module 'mongoose' {
     updateMany(
       filter?: RootFilterQuery<RawDocType>,
       update?: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateMany', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      UpdateWriteOpResult,
+      DocType,
+      THelpers,
+      RawDocType,
+      'updateMany',
+      TInstanceMethods
+    >;
 
     /**
      * Declare and/or execute this query as an updateOne() operation. Same as
@@ -856,8 +1144,15 @@ declare module 'mongoose' {
     updateOne(
       filter?: RootFilterQuery<RawDocType>,
       update?: UpdateQuery<RawDocType> | UpdateWithAggregationPipeline,
-      options?: QueryOptions<DocType> | null
-    ): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateOne', TInstanceMethods>;
+      options?: QueryOptions<DocType> | null,
+    ): QueryWithHelpers<
+      UpdateWriteOpResult,
+      DocType,
+      THelpers,
+      RawDocType,
+      'updateOne',
+      TInstanceMethods
+    >;
 
     /**
      * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,
diff --git a/types/schemaoptions.d.ts b/types/schemaoptions.d.ts
index 4df87a806ea74092bfcda06461463078ac7ee489..771527f189c470ea23261e558387478a5728ca82 100644
--- a/types/schemaoptions.d.ts
+++ b/types/schemaoptions.d.ts
@@ -1,10 +1,10 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   interface SchemaTimestampsConfig {
     createdAt?: boolean | string;
     updatedAt?: boolean | string;
-    currentTime?: () => (NativeDate | number);
+    currentTime?: () => NativeDate | number;
   }
 
   type TypeKeyBaseType = string;
@@ -16,7 +16,11 @@ declare module 'mongoose' {
     QueryHelpers = {},
     TStaticMethods = {},
     TVirtuals = {},
-    THydratedDocumentType = HydratedDocument<DocType, TInstanceMethods, QueryHelpers>
+    THydratedDocumentType = HydratedDocument<
+      DocType,
+      TInstanceMethods,
+      QueryHelpers
+    >,
   > {
     /**
      * By default, Mongoose's init() function creates all the indexes defined in your model's schema by
@@ -50,7 +54,10 @@ declare module 'mongoose' {
      * Mongoose supports MongoDBs capped collections. To specify the underlying MongoDB collection be capped, set
      * the capped option to the maximum size of the collection in bytes.
      */
-    capped?: boolean | number | { size?: number; max?: number; autoIndexId?: boolean; };
+    capped?:
+      | boolean
+      | number
+      | { size?: number; max?: number; autoIndexId?: boolean };
     /** Sets a default collation for every query and aggregation. */
     collation?: mongodb.CollationOptions;
 
@@ -123,7 +130,9 @@ declare module 'mongoose' {
     /**
      * Set a default readConcern for all queries at the schema level
      */
-    readConcern?: { level: 'local' | 'available' | 'majority' | 'snapshot' | 'linearizable' }
+    readConcern?: {
+      level: 'local' | 'available' | 'majority' | 'snapshot' | 'linearizable';
+    };
     /** Allows setting write concern at the schema level. */
     writeConcern?: WriteConcern;
     /** defaults to true. */
@@ -190,7 +199,7 @@ declare module 'mongoose' {
      * incremented even if these paths are updated). DO NOT do this unless you know what you're doing.
      * For subdocuments, include this on the parent document using the fully qualified path.
      */
-    skipVersioning?: { [key: string]: boolean; };
+    skipVersioning?: { [key: string]: boolean };
     /**
      * Validation errors in a single nested schema are reported
      * both on the child and on the parent schema.
@@ -210,7 +219,7 @@ declare module 'mongoose' {
      * You can suppress the warning by setting { suppressReservedKeysWarning: true } schema options. Keep in mind that this
      * can break plugins that rely on these reserved names.
      */
-    suppressReservedKeysWarning?: boolean,
+    suppressReservedKeysWarning?: boolean;
 
     /**
      * Model Statics methods.
@@ -220,27 +229,40 @@ declare module 'mongoose' {
       {},
       { [name: string]: (this: Model<DocType>, ...args: any[]) => unknown },
       AddThisParameter<TStaticMethods, Model<DocType>>
-    >
+    >;
 
     /**
      * Document instance methods.
      */
     methods?: IfEquals<
-    TInstanceMethods,
-    {},
-    Record<any, (this: THydratedDocumentType, ...args: any) => unknown>,
-    AddThisParameter<TInstanceMethods, THydratedDocumentType> & AnyObject
-    >
+      TInstanceMethods,
+      {},
+      Record<any, (this: THydratedDocumentType, ...args: any) => unknown>,
+      AddThisParameter<TInstanceMethods, THydratedDocumentType> & AnyObject
+    >;
 
     /**
      * Query helper functions.
      */
     query?: IfEquals<
-    QueryHelpers,
-    {},
-    Record<any, <T extends QueryWithHelpers<unknown, THydratedDocumentType, QueryHelpers, DocType>>(this: T, ...args: any) => T>,
-    QueryHelpers
-    >
+      QueryHelpers,
+      {},
+      Record<
+        any,
+        <
+          T extends QueryWithHelpers<
+            unknown,
+            THydratedDocumentType,
+            QueryHelpers,
+            DocType
+          >,
+        >(
+          this: T,
+          ...args: any
+        ) => T
+      >,
+      QueryHelpers
+    >;
 
     /**
      * Set whether to cast non-array values to arrays.
@@ -251,7 +273,11 @@ declare module 'mongoose' {
     /**
      * Virtual paths.
      */
-    virtuals?: SchemaOptionsVirtualsPropertyType<DocType, TVirtuals, TInstanceMethods>,
+    virtuals?: SchemaOptionsVirtualsPropertyType<
+      DocType,
+      TVirtuals,
+      TInstanceMethods
+    >;
 
     /**
      * Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.
@@ -265,6 +291,6 @@ declare module 'mongoose' {
     id: true;
     _id: true;
     timestamps: false;
-    versionKey: '__v'
+    versionKey: '__v';
   }
 }
diff --git a/types/schematypes.d.ts b/types/schematypes.d.ts
index aff686e1ec9732e368ca96b184baaac22cc10f1a..8f25ec47ee5559e8ea13e2a6f99c62b14a00b575 100644
--- a/types/schematypes.d.ts
+++ b/types/schematypes.d.ts
@@ -1,5 +1,4 @@
-declare module 'mongoose' {
-
+declare module 'mongoose-v8' {
   /** The Mongoose Date [SchemaType](/docs/schematypes.html). */
   type Date = Schema.Types.Date;
 
@@ -37,50 +36,109 @@ declare module 'mongoose' {
   /** The various Mongoose SchemaTypes. */
   const SchemaTypes: typeof Schema.Types;
 
-  type DefaultType<T> = T extends Schema.Types.Mixed ? any : Partial<ExtractMongooseArray<T>>;
+  type DefaultType<T> = T extends Schema.Types.Mixed
+    ? any
+    : Partial<ExtractMongooseArray<T>>;
 
   class SchemaTypeOptions<T, EnforcedDocType = any> {
-    type?:
-    T extends string ? StringSchemaDefinition :
-      T extends number ? NumberSchemaDefinition :
-        T extends boolean ? BooleanSchemaDefinition :
-          T extends NativeDate ? DateSchemaDefinition :
-            T extends Map<any, any> ? SchemaDefinition<typeof Map> :
-              T extends Buffer ? SchemaDefinition<typeof Buffer> :
-                T extends Types.ObjectId ? ObjectIdSchemaDefinition :
-                  T extends Types.ObjectId[] ? AnyArray<ObjectIdSchemaDefinition> | AnyArray<SchemaTypeOptions<ObjectId, EnforcedDocType>> :
-                    T extends object[] ? (AnyArray<Schema<any, any, any>> | AnyArray<SchemaDefinition<Unpacked<T>>> | AnyArray<SchemaTypeOptions<Unpacked<T>, EnforcedDocType>>) :
-                      T extends string[] ? AnyArray<StringSchemaDefinition> | AnyArray<SchemaTypeOptions<string, EnforcedDocType>> :
-                        T extends number[] ? AnyArray<NumberSchemaDefinition> | AnyArray<SchemaTypeOptions<number, EnforcedDocType>> :
-                          T extends boolean[] ? AnyArray<BooleanSchemaDefinition> | AnyArray<SchemaTypeOptions<boolean, EnforcedDocType>> :
-                            T extends Function[] ? AnyArray<Function | string> | AnyArray<SchemaTypeOptions<Unpacked<T>, EnforcedDocType>> :
-                              T | typeof SchemaType | Schema<any, any, any> | SchemaDefinition<T> | Function | AnyArray<Function>;
+    type?: T extends string
+      ? StringSchemaDefinition
+      : T extends number
+        ? NumberSchemaDefinition
+        : T extends boolean
+          ? BooleanSchemaDefinition
+          : T extends NativeDate
+            ? DateSchemaDefinition
+            : T extends Map<any, any>
+              ? SchemaDefinition<typeof Map>
+              : T extends Buffer
+                ? SchemaDefinition<typeof Buffer>
+                : T extends Types.ObjectId
+                  ? ObjectIdSchemaDefinition
+                  : T extends Types.ObjectId[]
+                    ?
+                        | AnyArray<ObjectIdSchemaDefinition>
+                        | AnyArray<SchemaTypeOptions<ObjectId, EnforcedDocType>>
+                    : T extends object[]
+                      ?
+                          | AnyArray<Schema<any, any, any>>
+                          | AnyArray<SchemaDefinition<Unpacked<T>>>
+                          | AnyArray<
+                              SchemaTypeOptions<Unpacked<T>, EnforcedDocType>
+                            >
+                      : T extends string[]
+                        ?
+                            | AnyArray<StringSchemaDefinition>
+                            | AnyArray<
+                                SchemaTypeOptions<string, EnforcedDocType>
+                              >
+                        : T extends number[]
+                          ?
+                              | AnyArray<NumberSchemaDefinition>
+                              | AnyArray<
+                                  SchemaTypeOptions<number, EnforcedDocType>
+                                >
+                          : T extends boolean[]
+                            ?
+                                | AnyArray<BooleanSchemaDefinition>
+                                | AnyArray<
+                                    SchemaTypeOptions<boolean, EnforcedDocType>
+                                  >
+                            : T extends Function[]
+                              ?
+                                  | AnyArray<Function | string>
+                                  | AnyArray<
+                                      SchemaTypeOptions<
+                                        Unpacked<T>,
+                                        EnforcedDocType
+                                      >
+                                    >
+                              :
+                                  | T
+                                  | typeof SchemaType
+                                  | Schema<any, any, any>
+                                  | SchemaDefinition<T>
+                                  | Function
+                                  | AnyArray<Function>;
 
     /** Defines a virtual with the given name that gets/sets this path. */
     alias?: string | string[];
 
     /** Function or object describing how to validate this schematype. See [validation docs](https://mongoosejs.com/docs/validation.html). */
-    validate?: SchemaValidator<T, EnforcedDocType> | AnyArray<SchemaValidator<T, EnforcedDocType>>;
+    validate?:
+      | SchemaValidator<T, EnforcedDocType>
+      | AnyArray<SchemaValidator<T, EnforcedDocType>>;
 
     /** Allows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message. */
-    cast?: string |
-    boolean |
-    ((value: any) => T) |
-    [(value: any) => T, string] |
-    [((value: any) => T) | null, (value: any, path: string, model: Model<any>, kind: string) => string];
+    cast?:
+      | string
+      | boolean
+      | ((value: any) => T)
+      | [(value: any) => T, string]
+      | [
+          ((value: any) => T) | null,
+          (value: any, path: string, model: Model<any>, kind: string) => string,
+        ];
 
     /**
      * If true, attach a required validator to this path, which ensures this path
      * path cannot be set to a nullish value. If a function, Mongoose calls the
      * function and only checks for nullish values if the function returns a truthy value.
      */
-    required?: boolean | ((this: EnforcedDocType) => boolean) | [boolean, string] | [(this: EnforcedDocType) => boolean, string];
+    required?:
+      | boolean
+      | ((this: EnforcedDocType) => boolean)
+      | [boolean, string]
+      | [(this: EnforcedDocType) => boolean, string];
 
     /**
      * The default value for this path. If a function, Mongoose executes the function
      * and uses the return value as the default.
      */
-    default?: DefaultType<T> | ((this: EnforcedDocType, doc: any) => DefaultType<T>) | null;
+    default?:
+      | DefaultType<T>
+      | ((this: EnforcedDocType, doc: any) => DefaultType<T>)
+      | null;
 
     /**
      * The model that `populate()` should use if populating this path.
@@ -145,16 +203,37 @@ declare module 'mongoose' {
     set?: (value: any, priorVal?: T, doc?: this) => any;
 
     /** array of allowed values for this path. Allowed for strings, numbers, and arrays of strings */
-    enum?: Array<string | number | null> | ReadonlyArray<string | number | null> | { values: Array<string | number | null> | ReadonlyArray<string | number | null>, message?: string } | { [path: string]: string | number | null };
+    enum?:
+      | Array<string | number | null>
+      | ReadonlyArray<string | number | null>
+      | {
+          values:
+            | Array<string | number | null>
+            | ReadonlyArray<string | number | null>;
+          message?: string;
+        }
+      | { [path: string]: string | number | null };
 
     /** The default [subtype](http://bsonspec.org/spec.html) associated with this buffer when it is stored in MongoDB. Only allowed for buffer paths */
     subtype?: number;
 
     /** The minimum value allowed for this path. Only allowed for numbers and dates. */
-    min?: number | NativeDate | [number, string] | [NativeDate, string] | readonly [number, string] | readonly [NativeDate, string];
+    min?:
+      | number
+      | NativeDate
+      | [number, string]
+      | [NativeDate, string]
+      | readonly [number, string]
+      | readonly [NativeDate, string];
 
     /** The maximum value allowed for this path. Only allowed for numbers and dates. */
-    max?: number | NativeDate | [number, string] | [NativeDate, string] | readonly [number, string] | readonly [NativeDate, string];
+    max?:
+      | number
+      | NativeDate
+      | [number, string]
+      | [NativeDate, string]
+      | readonly [number, string]
+      | readonly [NativeDate, string];
 
     /** Defines a TTL index on this path. Only allowed for dates. */
     expires?: string | number;
@@ -199,7 +278,11 @@ declare module 'mongoose' {
     reason?: Error;
   }
 
-  type ValidatorFunction<DocType = any> = (this: DocType, value: any, validatorProperties?: Validator) => any;
+  type ValidatorFunction<DocType = any> = (
+    this: DocType,
+    value: any,
+    validatorProperties?: Validator,
+  ) => any;
 
   class SchemaType<T = any, DocType = any> {
     /** SchemaType constructor */
@@ -208,7 +291,9 @@ declare module 'mongoose' {
     /** Get/set the function used to cast arbitrary values to this type. */
     static cast(caster?: Function | boolean): Function;
 
-    static checkRequired(checkRequired?: (v: any) => boolean): (v: any) => boolean;
+    static checkRequired(
+      checkRequired?: (v: any) => boolean,
+    ): (v: any) => boolean;
 
     /** Sets a default option for this schema type. */
     static set(option: string, value: any): void;
@@ -217,14 +302,31 @@ declare module 'mongoose' {
     static get(getter: (value: any) => any): void;
 
     /** Array containing default setters for all instances of this SchemaType */
-    static setters: ((val?: unknown, priorVal?: unknown, doc?: Document<unknown>, options?: Record<string, any> | null) => unknown)[];
+    static setters: ((
+      val?: unknown,
+      priorVal?: unknown,
+      doc?: Document<unknown>,
+      options?: Record<string, any> | null,
+    ) => unknown)[];
 
     /** The class that Mongoose uses internally to instantiate this SchemaType's `options` property. */
     OptionsConstructor: SchemaTypeOptions<T>;
 
     /** Cast `val` to this schema type. Each class that inherits from schema type should implement this function. */
-    cast(val: any, doc?: Document<any>, init?: boolean, prev?: any, options?: any): any;
-    cast<ResultType>(val: any, doc?: Document<any>, init?: boolean, prev?: any, options?: any): ResultType;
+    cast(
+      val: any,
+      doc?: Document<any>,
+      init?: boolean,
+      prev?: any,
+      options?: any,
+    ): any;
+    cast<ResultType>(
+      val: any,
+      doc?: Document<any>,
+      init?: boolean,
+      prev?: any,
+      options?: any,
+    ): ResultType;
 
     /** Sets a default value for this SchemaType. */
     default(val: any): any;
@@ -233,7 +335,9 @@ declare module 'mongoose' {
     get(fn: Function): this;
 
     /** Gets this SchemaType's embedded SchemaType, if any  */
-    getEmbeddedSchemaType<T = any, DocType = any>(): SchemaType<T, DocType> | undefined;
+    getEmbeddedSchemaType<T = any, DocType = any>():
+      | SchemaType<T, DocType>
+      | undefined;
 
     /**
      * Defines this path as immutable. Mongoose prevents you from changing
@@ -293,10 +397,18 @@ declare module 'mongoose' {
     validators: Validator[];
 
     /** Adds validator(s) for this document path. */
-    validate(obj: RegExp | ValidatorFunction<DocType> | Validator<DocType>, errorMsg?: string, type?: string): this;
+    validate(
+      obj: RegExp | ValidatorFunction<DocType> | Validator<DocType>,
+      errorMsg?: string,
+      type?: string,
+    ): this;
 
     /** Adds multiple validators for this document path. */
-    validateAll(validators: Array<RegExp | ValidatorFunction<DocType> | Validator<DocType>>): this;
+    validateAll(
+      validators: Array<
+        RegExp | ValidatorFunction<DocType> | Validator<DocType>
+      >,
+    ): this;
 
     /** Default options for this SchemaType */
     defaultOptions?: Record<string, any>;
@@ -308,10 +420,18 @@ declare module 'mongoose' {
         /** This schema type's name, to defend against minifiers that mangle function names. */
         static schemaName: 'Array';
 
-        static options: { castNonArrays: boolean; };
+        static options: { castNonArrays: boolean };
 
-        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;
-        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;
+        discriminator<T, U>(
+          name: string | number,
+          schema: Schema<T, U>,
+          value?: string,
+        ): U;
+        discriminator<D>(
+          name: string | number,
+          schema: Schema,
+          value?: string,
+        ): Model<D>;
 
         /** The schematype embedded in this array */
         caster?: SchemaType;
@@ -391,10 +511,18 @@ declare module 'mongoose' {
         /** This schema type's name, to defend against minifiers that mangle function names. */
         static schemaName: 'DocumentArray';
 
-        static options: { castNonArrays: boolean; };
+        static options: { castNonArrays: boolean };
 
-        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;
-        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;
+        discriminator<D>(
+          name: string | number,
+          schema: Schema,
+          value?: string,
+        ): Model<D>;
+        discriminator<T, U>(
+          name: string | number,
+          schema: Schema<T, U>,
+          value?: string,
+        ): U;
 
         /** The schema used for documents in this array */
         schema: Schema;
@@ -450,7 +578,10 @@ declare module 'mongoose' {
         defaultOptions: Record<string, any>;
       }
 
-      class Subdocument<DocType = unknown> extends SchemaType implements AcceptsDiscriminator {
+      class Subdocument<DocType = unknown>
+        extends SchemaType
+        implements AcceptsDiscriminator
+      {
         /** This schema type's name, to defend against minifiers that mangle function names. */
         static schemaName: string;
 
@@ -460,10 +591,24 @@ declare module 'mongoose' {
         /** Default options for this SchemaType */
         defaultOptions: Record<string, any>;
 
-        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;
-        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;
-
-        cast(val: any, doc?: Document<any>, init?: boolean, prev?: any, options?: any): HydratedSingleSubdocument<DocType>;
+        discriminator<T, U>(
+          name: string | number,
+          schema: Schema<T, U>,
+          value?: string,
+        ): U;
+        discriminator<D>(
+          name: string | number,
+          schema: Schema,
+          value?: string,
+        ): Model<D>;
+
+        cast(
+          val: any,
+          doc?: Document<any>,
+          init?: boolean,
+          prev?: any,
+          options?: any,
+        ): HydratedSingleSubdocument<DocType>;
       }
 
       class String extends SchemaType {
diff --git a/types/session.d.ts b/types/session.d.ts
index e7f41f7376d3bf605d22207be3146f4870db761b..6ff12b6a200a2fd81b729eb511dc046655628753 100644
--- a/types/session.d.ts
+++ b/types/session.d.ts
@@ -1,4 +1,4 @@
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
 
   type ClientSessionOptions = mongodb.ClientSessionOptions;
@@ -17,7 +17,6 @@ declare module 'mongoose' {
   }
 
   interface SessionStarter {
-
     /**
      * Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)
      * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),
diff --git a/types/types.d.ts b/types/types.d.ts
index 194917d69ec8e026d18bd2c07708a1fa6be3f6f1..74d367de33e8c3524737cf06927034cc9d90d12d 100644
--- a/types/types.d.ts
+++ b/types/types.d.ts
@@ -1,5 +1,4 @@
-
-declare module 'mongoose' {
+declare module 'mongoose-v8' {
   import mongodb = require('mongodb');
   import bson = require('bson');
 
@@ -52,25 +51,37 @@ declare module 'mongoose' {
 
     class Buffer extends NativeBuffer {
       /** Sets the subtype option and marks the buffer modified. */
-      subtype(subtype: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 128 | ToObjectOptions): void;
+      subtype(
+        subtype: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 128 | ToObjectOptions,
+      ): void;
 
       /** Converts this buffer to its Binary type representation. */
       toObject(subtype?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 128): mongodb.Binary;
     }
 
-    class Decimal128 extends mongodb.Decimal128 { }
+    class Decimal128 extends mongodb.Decimal128 {}
 
-    class DocumentArray<T> extends Types.Array<T extends Types.Subdocument ? T : Types.Subdocument<InferId<T>, any, T> & T> {
+    class DocumentArray<T> extends Types.Array<
+      T extends Types.Subdocument
+        ? T
+        : Types.Subdocument<InferId<T>, any, T> & T
+    > {
       /** DocumentArray constructor */
       constructor(values: AnyObject[]);
 
       isMongooseDocumentArray: true;
 
       /** Creates a subdocument casted to this schema. */
-      create(obj: any): T extends Types.Subdocument ? T : Types.Subdocument<InferId<T>> & T;
+      create(
+        obj: any,
+      ): T extends Types.Subdocument ? T : Types.Subdocument<InferId<T>> & T;
 
       /** Searches array items for the first document with a matching _id. */
-      id(id: any): (T extends Types.Subdocument ? T : Types.Subdocument<InferId<T>> & T) | null;
+      id(
+        id: any,
+      ):
+        | (T extends Types.Subdocument ? T : Types.Subdocument<InferId<T>> & T)
+        | null;
 
       push(...args: (AnyKeys<T> & AnyObject)[]): number;
     }
@@ -80,10 +91,13 @@ declare module 'mongoose' {
       toObject(options?: ToObjectOptions & { flattenMaps?: boolean }): any;
     }
 
-    class ObjectId extends mongodb.ObjectId {
-    }
+    class ObjectId extends mongodb.ObjectId {}
 
-    class Subdocument<IdType = unknown, TQueryHelpers = any, DocType = any> extends Document<IdType, TQueryHelpers, DocType> {
+    class Subdocument<
+      IdType = unknown,
+      TQueryHelpers = any,
+      DocType = any,
+    > extends Document<IdType, TQueryHelpers, DocType> {
       $isSingleNested: true;
 
       /** Returns the top level document of this sub-document. */
@@ -96,7 +110,11 @@ declare module 'mongoose' {
       $parent(): Document;
     }
 
-    class ArraySubdocument<IdType = any, TQueryHelpers = unknown, DocType = unknown> extends Subdocument<IdType, TQueryHelpers, DocType> {
+    class ArraySubdocument<
+      IdType = any,
+      TQueryHelpers = unknown,
+      DocType = unknown,
+    > extends Subdocument<IdType, TQueryHelpers, DocType> {
       /** Returns this sub-documents parent array. */
       parentArray(): Types.DocumentArray<unknown>;
     }
diff --git a/types/utility.d.ts b/types/utility.d.ts
index 7c6df5618187c0070ca87cbcec14417fb69d1a8f..752d9e33ce601dfcdf1f9c788cf07a3afd107d2c 100644
--- a/types/utility.d.ts
+++ b/types/utility.d.ts
@@ -1,5 +1,7 @@
-declare module 'mongoose' {
-  type IfAny<IFTYPE, THENTYPE, ELSETYPE = IFTYPE> = 0 extends (1 & IFTYPE) ? THENTYPE : ELSETYPE;
+declare module 'mongoose-v8' {
+  type IfAny<IFTYPE, THENTYPE, ELSETYPE = IFTYPE> = 0 extends 1 & IFTYPE
+    ? THENTYPE
+    : ELSETYPE;
   type IfUnknown<IFTYPE, THENTYPE> = unknown extends IFTYPE ? THENTYPE : IFTYPE;
 
   type WithLevel1NestedPaths<T, K extends keyof T = keyof T> = {
@@ -23,25 +25,29 @@ declare module 'mongoose' {
   type WithoutUndefined<T> = T extends undefined ? never : T;
 
   /**
-    * @summary Removes keys from a type
-    * @description It helps to exclude keys from a type
-    * @param {T} T A generic type to be checked.
-    * @param {K} K Keys from T that are to be excluded from the generic type
-    * @returns T with the keys in K excluded
-    */
+   * @summary Removes keys from a type
+   * @description It helps to exclude keys from a type
+   * @param {T} T A generic type to be checked.
+   * @param {K} K Keys from T that are to be excluded from the generic type
+   * @returns T with the keys in K excluded
+   */
   type ExcludeKeys<T, K extends keyof T> = {
     [P in keyof T as P extends K ? never : P]: T[P];
   };
 
-  type Unpacked<T> = T extends (infer U)[] ?
-    U :
-    T extends ReadonlyArray<infer U> ? U : T;
+  type Unpacked<T> = T extends (infer U)[]
+    ? U
+    : T extends ReadonlyArray<infer U>
+      ? U
+      : T;
 
-  type UnpackedIntersection<T, U> = T extends null ? null : T extends (infer A)[]
-    ? (Omit<A, keyof U> & U)[]
-    : keyof U extends never
-      ? T
-      : Omit<T, keyof U> & U;
+  type UnpackedIntersection<T, U> = T extends null
+    ? null
+    : T extends (infer A)[]
+      ? (Omit<A, keyof U> & U)[]
+      : keyof U extends never
+        ? T
+        : Omit<T, keyof U> & U;
 
   type MergeType<A, B> = Omit<A, keyof B> & B;
 
@@ -53,44 +59,45 @@ declare module 'mongoose' {
   type FlatRecord<T> = { [K in keyof T]: T[K] };
 
   /**
-    * @summary Checks if a type is "Record" or "any".
-    * @description It Helps to check if user has provided schema type "EnforcedDocType"
-    * @param {T} T A generic type to be checked.
-    * @returns true if {@link T} is Record OR false if {@link T} is of any type.
-    */
-  type IsItRecordAndNotAny<T> = IfEquals<T, any, false, T extends Record<any, any> ? true : false>;
-
-/**
- * @summary Checks if two types are identical.
- * @param {T} T The first type to be compared with {@link U}.
- * @param {U} U The seconde type to be compared with {@link T}.
- * @param {Y} Y A type to be returned if {@link T} &  {@link U} are identical.
- * @param {N} N A type to be returned if {@link T} &  {@link U} are not identical.
- */
-type IfEquals<T, U, Y = true, N = false> =
-    (<G>() => G extends T ? 1 : 0) extends
-    (<G>() => G extends U ? 1 : 0) ? Y : N;
+   * @summary Checks if a type is "Record" or "any".
+   * @description It Helps to check if user has provided schema type "EnforcedDocType"
+   * @param {T} T A generic type to be checked.
+   * @returns true if {@link T} is Record OR false if {@link T} is of any type.
+   */
+  type IsItRecordAndNotAny<T> = IfEquals<
+    T,
+    any,
+    false,
+    T extends Record<any, any> ? true : false
+  >;
 
-/**
- * @summary Extracts 'this' parameter from a function, if it exists. Otherwise, returns fallback.
- * @param {T} T Function type to extract 'this' parameter from.
- * @param {F} F Fallback type to return if 'this' parameter does not exist.
- */
-type ThisParameter<T, F> = T extends { (this: infer This): void }
-  ? This
-  : F;
+  /**
+   * @summary Checks if two types are identical.
+   * @param {T} T The first type to be compared with {@link U}.
+   * @param {U} U The seconde type to be compared with {@link T}.
+   * @param {Y} Y A type to be returned if {@link T} &  {@link U} are identical.
+   * @param {N} N A type to be returned if {@link T} &  {@link U} are not identical.
+   */
+  type IfEquals<T, U, Y = true, N = false> =
+    (<G>() => G extends T ? 1 : 0) extends <G>() => G extends U ? 1 : 0 ? Y : N;
 
-/**
- * @summary Decorates all functions in an object with 'this' parameter.
- * @param {T} T Object with functions as values to add 'D' parameter to as 'this'. {@link D}
- * @param {D} D The type to be added as 'this' parameter to all functions in {@link T}.
- */
-type AddThisParameter<T, D> = {
-  [K in keyof T]: T[K] extends (...args: infer A) => infer R
-    ? ThisParameter<T[K], unknown> extends unknown
-      ? (this: D, ...args: A) => R
-      : T[K]
-    : T[K];
-};
+  /**
+   * @summary Extracts 'this' parameter from a function, if it exists. Otherwise, returns fallback.
+   * @param {T} T Function type to extract 'this' parameter from.
+   * @param {F} F Fallback type to return if 'this' parameter does not exist.
+   */
+  type ThisParameter<T, F> = T extends { (this: infer This): void } ? This : F;
 
+  /**
+   * @summary Decorates all functions in an object with 'this' parameter.
+   * @param {T} T Object with functions as values to add 'D' parameter to as 'this'. {@link D}
+   * @param {D} D The type to be added as 'this' parameter to all functions in {@link T}.
+   */
+  type AddThisParameter<T, D> = {
+    [K in keyof T]: T[K] extends (...args: infer A) => infer R
+      ? ThisParameter<T[K], unknown> extends unknown
+        ? (this: D, ...args: A) => R
+        : T[K]
+      : T[K];
+  };
 }
diff --git a/types/validation.d.ts b/types/validation.d.ts
index 3310d9544353a52d15398dd7174c87b97322cd4d..3dcd605253c6f31baaea2c6f81365287f0587397 100644
--- a/types/validation.d.ts
+++ b/types/validation.d.ts
@@ -1,6 +1,11 @@
-declare module 'mongoose' {
-
-  type SchemaValidator<T, EnforcedDocType> = RegExp | [RegExp, string] | Function | [Function, string] | ValidateOpts<T, EnforcedDocType> | ValidateOpts<T, EnforcedDocType>[];
+declare module 'mongoose-v8' {
+  type SchemaValidator<T, EnforcedDocType> =
+    | RegExp
+    | [RegExp, string]
+    | Function
+    | [Function, string]
+    | ValidateOpts<T, EnforcedDocType>
+    | ValidateOpts<T, EnforcedDocType>[];
 
   interface ValidatorProps {
     path: string;
@@ -13,18 +18,25 @@ declare module 'mongoose' {
     (props: ValidatorProps): string;
   }
 
-  type ValidateFn<T, EnforcedDocType> =
-    (this: EnforcedDocType, value: any, props?: ValidatorProps & Record<string, any>) => boolean;
+  type ValidateFn<T, EnforcedDocType> = (
+    this: EnforcedDocType,
+    value: any,
+    props?: ValidatorProps & Record<string, any>,
+  ) => boolean;
 
-  type AsyncValidateFn<T, EnforcedDocType> =
-    (this: EnforcedDocType, value: any, props?: ValidatorProps & Record<string, any>) => Promise<boolean>;
+  type AsyncValidateFn<T, EnforcedDocType> = (
+    this: EnforcedDocType,
+    value: any,
+    props?: ValidatorProps & Record<string, any>,
+  ) => Promise<boolean>;
 
   interface ValidateOpts<T, EnforcedDocType> {
     msg?: string;
     message?: string | ValidatorMessageFn;
     type?: string;
-    validator: ValidateFn<T, EnforcedDocType>
-    | AsyncValidateFn<T, EnforcedDocType>;
+    validator:
+      | ValidateFn<T, EnforcedDocType>
+      | AsyncValidateFn<T, EnforcedDocType>;
     propsParameter?: boolean;
   }
 }
diff --git a/types/virtuals.d.ts b/types/virtuals.d.ts
index 2ec48a496f1baf6000bcdaf07d9d2f737547163a..40200f16c3219228ef2f5386535144535d424239 100644
--- a/types/virtuals.d.ts
+++ b/types/virtuals.d.ts
@@ -1,14 +1,43 @@
-declare module 'mongoose' {
-    type VirtualPathFunctions<DocType = {}, PathValueType = unknown, TInstanceMethods = {}> = {
-      get?: TVirtualPathFN<DocType, PathValueType, TInstanceMethods, PathValueType>;
-      set?: TVirtualPathFN<DocType, PathValueType, TInstanceMethods, void>;
-      options?: VirtualTypeOptions<HydratedDocument<DocType, TInstanceMethods>, DocType>;
-    };
+declare module 'mongoose-v8' {
+  type VirtualPathFunctions<
+    DocType = {},
+    PathValueType = unknown,
+    TInstanceMethods = {},
+  > = {
+    get?: TVirtualPathFN<
+      DocType,
+      PathValueType,
+      TInstanceMethods,
+      PathValueType
+    >;
+    set?: TVirtualPathFN<DocType, PathValueType, TInstanceMethods, void>;
+    options?: VirtualTypeOptions<
+      HydratedDocument<DocType, TInstanceMethods>,
+      DocType
+    >;
+  };
 
-  type TVirtualPathFN<DocType = {}, PathType = unknown, TInstanceMethods = {}, TReturn = unknown> =
-    <T = HydratedDocument<DocType, TInstanceMethods>>(this: Document<any, any, DocType> & DocType, value: PathType, virtual: VirtualType<T>, doc: Document<any, any, DocType> & DocType) => TReturn;
+  type TVirtualPathFN<
+    DocType = {},
+    PathType = unknown,
+    TInstanceMethods = {},
+    TReturn = unknown,
+  > = <T = HydratedDocument<DocType, TInstanceMethods>>(
+    this: Document<any, any, DocType> & DocType,
+    value: PathType,
+    virtual: VirtualType<T>,
+    doc: Document<any, any, DocType> & DocType,
+  ) => TReturn;
 
-    type SchemaOptionsVirtualsPropertyType<DocType = any, VirtualPaths = Record<any, unknown>, TInstanceMethods = {}> = {
-      [K in keyof VirtualPaths]: VirtualPathFunctions<IsItRecordAndNotAny<DocType> extends true ? DocType : any, VirtualPaths[K], TInstanceMethods>
-    };
+  type SchemaOptionsVirtualsPropertyType<
+    DocType = any,
+    VirtualPaths = Record<any, unknown>,
+    TInstanceMethods = {},
+  > = {
+    [K in keyof VirtualPaths]: VirtualPathFunctions<
+      IsItRecordAndNotAny<DocType> extends true ? DocType : any,
+      VirtualPaths[K],
+      TInstanceMethods
+    >;
+  };
 }
